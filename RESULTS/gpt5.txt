# NodeBench - OpenAI GPT 5

1. Pass
2. Pass
3. Fail (ValueError: too many values to unpack (expected 2))
4. Pass
5. Pass
6. Pass
7. Pass
8. Pass
9. Pass
10. Pass
11. Pass
12. Pass
13. Pass
14. Pass
15. Pass
16. Pass, SRC:
```
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hello, GPT-5 Thinking mini!</title>
  <style>
    :root{
      --bg1: #0f172a;
      --bg2: #071129;
      --accent1: #7c3aed;
      --accent2: #06b6d4;
      --glass: rgba(255,255,255,0.06);
      --shadow: 0 8px 30px rgba(2,6,23,0.6);
      --glass-border: rgba(255,255,255,0.06);
    }

    /* Reset-ish */
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;
      background: linear-gradient(160deg,var(--bg1) 0%, var(--bg2) 60%);
      color: #fff;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:32px;
    }

    /* Container */
    .card{
      width: min(960px, 92vw);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:20px;
      padding: clamp(24px, 4vw, 48px);
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(6px) saturate(120%);
    }

    /* Subtle moving gradient overlay */
    .card::before{
      content:"";
      position:absolute;
      inset:-40%;
      background: radial-gradient(closest-side, rgba(124,58,237,0.12), transparent 30%),
                  radial-gradient(circle at 80% 20%, rgba(6,182,212,0.08), transparent 25%);
      transform: rotate(12deg);
      animation: float 8s linear infinite;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes float{
      0%{transform:rotate(12deg) translateY(0)}
      50%{transform:rotate(12deg) translateY(6%)}
      100%{transform:rotate(12deg) translateY(0)}
    }

    /* Heading layout */
    .headline{
      display:flex;
      align-items:center;
      gap:24px;
      margin:0 0 12px 0;
    }
    .logo{
      width:84px;
      height:84px;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-shrink:0;
      background: linear-gradient(135deg,var(--accent1),var(--accent2));
      box-shadow: 0 6px 20px rgba(12,18,40,0.6), inset 0 -6px 18px rgba(255,255,255,0.06);
      position:relative;
    }
    .logo svg{width:56px;height:56px;filter: drop-shadow(0 6px 14px rgba(0,0,0,0.45));}

    h1{
      font-weight:700;
      font-size: clamp(28px, 4.6vw, 42px);
      line-height:1;
      letter-spacing:-0.02em;
      margin:0;
      display:flex;
      flex-direction:column;
    }
    h1 .small{font-weight:500; font-size: clamp(12px, 1.6vw, 14px); opacity:0.85}

    /* Animated greeting text */
    .greeting{
      margin-top: 10px;
      display:inline-grid;
      grid-auto-flow:column;
      gap:8px;
      align-items:center;
    }

    .pill{
      background: linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      padding: 10px 16px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      gap:12px;
      box-shadow: 0 4px 18px rgba(2,6,23,0.45);
      border: 1px solid rgba(255,255,255,0.04);
      transform: translateZ(0);
    }

    .g-text{
      font-family: "Segoe UI", Roboto, system-ui, -apple-system;
      font-weight:700;
      font-size: clamp(16px, 2.4vw, 22px);
      color: white;
      display:inline-flex;
      gap:6px;
      align-items:center;
    }

    /* Animated letters */
    .char{
      display:inline-block;
      transform-origin:50% 80%;
      animation: wave 1200ms ease-in-out infinite;
      will-change:transform, opacity;
      text-shadow: 0 6px 18px rgba(0,0,0,0.5);
    }
    /* create stagger via CSS variable --i */
    .char { animation-delay: calc(var(--i) * 70ms); }
    @keyframes wave{
      0%{transform: translateY(0) rotateX(0) scale(1); opacity:1}
      40%{transform: translateY(-6%) rotateX(8deg) scale(1.03); opacity:1}
      80%{transform: translateY(0) rotateX(0) scale(1); opacity:1}
      100%{transform: translateY(0) rotateX(0) scale(1); opacity:1}
    }

    /* small sparkle */
    .spark{
      width:10px;
      height:10px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, #fff, transparent 40%);
      box-shadow: 0 0 12px 3px rgba(124,58,237,0.25), 0 0 20px 6px rgba(6,182,212,0.12);
      transform: translateY(-8px) scale(0.9);
      filter: blur(0.15px);
      opacity:0.95;
    }

    /* subtext & controls */
    .meta{
      margin-top:18px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .desc{
      color:rgba(255,255,255,0.78);
      font-size:14px;
    }
    .actions{display:flex; gap:10px; align-items:center;}
    .btn{
      background: linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      color:white;
      cursor:pointer;
      display:inline-flex;
      gap:8px;
      align-items:center;
      font-weight:600;
      font-size:13px;
    }
    .btn:active{transform: translateY(1px)}
    .btn.secondary{opacity:0.9; font-weight:500}
    .copy{
      background:transparent;
      border:none;
      color:inherit;
      cursor:pointer;
    }

    footer.note{
      margin-top:18px;
      color:rgba(255,255,255,0.06);
      font-size:12px;
      text-align:right;
    }

    /* accessibility: reduce motion */
    @media (prefers-reduced-motion: reduce){
      .card::before, .char { animation: none !important; }
    }

    /* responsive tweaks */
    @media (max-width:520px){
      .headline{gap:14px}
      .logo{width:60px;height:60px;border-radius:12px}
    }
  </style>
</head>
<body>
  <main class="card" role="main" aria-labelledby="greet">
    <header class="headline" aria-hidden="false">
      <div class="logo" aria-hidden="true" title="GPT-5 Thinking mini">
        <!-- Abstract glyph representing 'thinking' & 'spark' -->
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img">
          <defs>
            <linearGradient id="g1" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0" stop-color="#ffffff" stop-opacity="0.98"/>
              <stop offset="1" stop-color="#ffffff" stop-opacity="0.7"/>
            </linearGradient>
          </defs>
          <circle cx="32" cy="28" r="18" fill="rgba(255,255,255,0.06)"/>
          <path d="M16 36c6-10 24-10 28 0" stroke="url(#g1)" stroke-width="2.8" fill="none" stroke-linecap="round"/>
          <circle cx="42" cy="16" r="3.6" fill="#fff" opacity="0.92"/>
          <circle cx="22" cy="18" r="2.4" fill="#fff" opacity="0.9"/>
        </svg>
      </div>

      <h1 id="greet">
        <span class="small">A warm, pixel-perfect greeting from</span>
        <span style="display:flex;align-items:center;gap:12px;margin-top:8px;">
          <span style="font-size:1.02em;">Hello,</span>
          <div class="greeting" aria-hidden="false">
            <div class="pill" role="img" aria-label="Greeting">
              <div class="g-text" id="greetingText" aria-live="polite"></div>
              <div class="spark" aria-hidden="true"></div>
            </div>
          </div>
        </span>
      </h1>
    </header>

    <section class="meta" aria-label="greeting controls">
      <p class="desc">A playful, accessible "Hello" crafted with HTML/CSS/JS â€” no external libraries. Press <strong>Duplicate</strong> to copy the greeting or <strong>Remix</strong> to toggle a sparkle effect.</p>

      <div class="actions">
        <button class="btn" id="dupBtn" title="Copy greeting to clipboard">ðŸ“‹ Duplicate</button>
        <button class="btn secondary" id="remixBtn" title="Toggle extra sparkle">âœ¨ Remix</button>
      </div>
    </section>

    <footer class="note" aria-hidden="true">
      Fancy single-file greeting â€¢ Built for fun
    </footer>
  </main>

  <script>
    /*
      Fancy single-file "Hello, GPT-5 Thinking mini!" generator.
      - Builds the greeting letter-by-letter with a subtle wave animation (staggered via --i).
      - Duplicate button copies the plain greeting text to clipboard.
      - Remix toggles an extra randomized sparkle animation (CSS-only fallback respected).
    */

    // The display name â€” per instructions, this assistant identifies as:
    const NAME = "GPT-5 Thinking mini";

    // Build the greeting string: "GPT-5 Thinking mini!" (we replace Hello already in markup)
    const greetingContainer = document.getElementById('greetingText');

    function buildGreeting(name){
      // We'll render: "<Name>!"
      greetingContainer.innerHTML = ""; // clear
      const text = `${name}!`;
      // Create animated span per character
      for(let i=0;i<text.length;i++){
        const ch = text[i];
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = ch;
        // Use CSS var for stagger
        span.style.setProperty('--i', String(i));
        // Slight color gradient per char using inline style (no external assets)
        const hue = 200 + (i * 6); // rotate hue for subtle color
        span.style.color = `hsl(${hue}deg 90% 92%)`;
        greetingContainer.appendChild(span);
      }
    }

    buildGreeting(NAME);

    // Copy plain text (no decoration) to clipboard
    document.getElementById('dupBtn').addEventListener('click', async () => {
      const plain = `Hello, ${NAME}!`;
      try{
        await navigator.clipboard.writeText(plain);
        // quick feedback
        const old = document.getElementById('dupBtn').textContent;
        document.getElementById('dupBtn').textContent = 'âœ… Copied';
        setTimeout(()=> document.getElementById('dupBtn').textContent = old, 1200);
      }catch(e){
        // fallback: select and prompt
        alert('Copy failed â€” your browser may block clipboard. Text to copy:\\n' + plain);
      }
    });

    // Remix: toggles an extra sparkle effect (we'll quickly add tiny transient bursts)
    const remixBtn = document.getElementById('remixBtn');
    let remixOn = false;

    remixBtn.addEventListener('click', ()=>{
      remixOn = !remixOn;
      remixBtn.textContent = remixOn ? 'ðŸŒŸ Remix ON' : 'âœ¨ Remix';
      if(remixOn) startSparks();
    });

    // Simple ephemeral spark particles using DOM (keeps everything in one file, lightweight)
    function startSparks(){
      // create a few sparks that fade and float in the pill area
      const container = document.querySelector('.pill');
      let sparks = 0;
      const max = 12;
      const doOne = ()=>{
        if(!remixOn) return;
        if(sparks > max) { setTimeout(()=>{ sparks=0; if(remixOn) doOne(); }, 800); return; }
        sparks++;
        const s = document.createElement('div');
        s.setAttribute('aria-hidden','true');
        s.style.position = 'absolute';
        s.style.width = (6 + Math.random()*10) + 'px';
        s.style.height = s.style.width;
        s.style.borderRadius = '50%';
        s.style.left = (20 + Math.random()*80) + '%';
        s.style.top = (20 + Math.random()*60) + '%';
        s.style.pointerEvents = 'none';
        const h = 240 + Math.round(Math.random()*70);
        s.style.background = `radial-gradient(circle at 30% 30%, rgba(255,255,255,0.98), rgba(255,255,255,0.6) 25%, rgba(124,58,237,0.18) 50%, transparent 60%)`;
        s.style.boxShadow = `0 6px 18px rgba(6,182,212,0.12), 0 0 14px rgba(124,58,237,0.14)`;
        s.style.opacity = '0';
        s.style.transform = 'translateY(0) scale(0.6)';
        s.style.transition = 'transform 850ms cubic-bezier(.2,.9,.3,1), opacity 850ms ease-out';
        container.appendChild(s);
        // force reflow
        void s.offsetWidth;
        s.style.opacity = '1';
        s.style.transform = `translateY(${ -20 - Math.random()*40 }px) scale(1)`;
        setTimeout(()=>{
          s.style.opacity = '0';
          s.style.transform = `translateY(${ -80 - Math.random()*60 }px) scale(0.2)`;
          setTimeout(()=> { try{ s.remove(); }catch(_){}} , 900);
        }, 300 + Math.random()*700);
        // spawn more
        setTimeout(()=>{ if(remixOn) doOne(); }, 80 + Math.random()*240);
      };
      doOne();
    }

    // Respect reduced motion
    (function respectReducedMotion(){
      const mq = window.matchMedia('(prefers-reduced-motion: reduce)');
      if(mq.matches){
        // make text static
        document.querySelectorAll('.char').forEach((el)=>el.style.animation='none');
      }
      mq.addEventListener?.('change', ()=> location.reload());
    })();

    // small accessibility: announce greeting on load
    window.addEventListener('load', ()=>{
      // set an accessible label (screen readers will read the aria-live container)
      const live = document.getElementById('greet');
      live.setAttribute('aria-label', `Hello, ${NAME}!`);
    });
  </script>
</body>
</html>

```

17. Unfortunate FAIL due to CSS issues (it was so clever too! :[) Source:
```
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Richard's Linux PC Repair â€” Professional FOSS-First Repair & Support</title>
  <meta name="description" content="Richard's Linux PC Repair â€” professional repair, upgrades, and support for Linux desktops and laptops. A friendly FOSS-first technician who does not service Windows or Mac systems."/>
  <style>
    :root{
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #94a3b8;
      --accent: #0ea5a4; /* teal */
      --accent-2: #7c3aed; /* purple */
      --glass: rgba(255,255,255,0.04);
      --radius: 12px;
      --max-width: 1080px;
      --container-padding: 28px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:
        radial-gradient(1200px 600px at 10% 10%, rgba(124,58,237,0.06), transparent 8%),
        radial-gradient(800px 400px at 90% 90%, rgba(14,165,164,0.04), transparent 8%),
        linear-gradient(180deg, var(--bg) 0%, #071126 100%);
      color: #e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:32px;
    }

    .wrap{
      width:100%;
      max-width:var(--max-width);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: calc(var(--radius) + 4px);
      box-shadow: 0 12px 40px rgba(2,6,23,0.7);
      border: 1px solid rgba(255,255,255,0.04);
      overflow:hidden;
      display:grid;
      grid-template-columns: 360px 1fr;
      min-height:520px;
    }

    /* Sidebar */
    .sidebar{
      padding:var(--container-padding);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008));
      border-right: 1px solid rgba(255,255,255,0.02);
      display:flex;
      flex-direction:column;
      gap:18px;
    }
    .brand{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .logo{
      width:64px;
      height:64px;
      border-radius:12px;
      display:grid;
      place-items:center;
      background: linear-gradient(135deg, var(--accent-2), var(--accent));
      box-shadow: 0 8px 22px rgba(12,18,40,0.6), inset 0 -6px 14px rgba(255,255,255,0.06);
      font-weight:800;
      color:white;
      font-family: "Georgia", serif;
      font-size:18px;
      letter-spacing:0.6px;
    }
    .brand h1{
      margin:0;
      font-size:18px;
      line-height:1.05;
      letter-spacing:-0.02em;
    }
    .brand p{margin:0;color:var(--muted);font-size:13px}

    .nav{
      margin-top:6px;
      display:flex;
      gap:8px;
      flex-direction:column;
    }
    .nav a{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-radius:10px;
      color: #dfe8f5;
      text-decoration:none;
      font-weight:600;
      font-size:14px;
    }
    .nav a.active{
      background: linear-gradient(90deg, rgba(124,58,237,0.12), rgba(14,165,164,0.08));
      box-shadow: 0 6px 18px rgba(10,12,20,0.5);
    }
    .muted{
      color:var(--muted);
      font-size:13px;
    }

    .contact-card{
      margin-top:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .contact-card h4{margin:0 0 6px 0}
    .contact-card p{margin:0;color:var(--muted);font-size:13px}
    .btn{
      display:inline-block;
      padding:8px 12px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      color:white;
      border-radius:8px;
      border:none;
      font-weight:700;
      cursor:pointer;
      margin-top:10px;
      text-decoration:none;
    }
    .btn:active{transform:translateY(1px)}

    /* Content area */
    .content{
      padding:var(--container-padding);
      min-height:520px;
      display:flex;
      flex-direction:column;
      gap:18px;
    }
    .hero{
      display:flex;
      gap:18px;
      align-items:center;
      justify-content:space-between;
    }
    .intro{
      max-width:68%;
    }
    .intro h2{
      margin:0 0 8px 0;
      font-size:22px;
      letter-spacing:-0.01em;
    }
    .intro p{margin:0;color:var(--muted);font-size:15px}

    .badge{
      background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));
      padding:8px 12px;
      border-radius:999px;
      font-weight:700;
      color:#f8faff;
      border:1px solid rgba(255,255,255,0.03);
      display:inline-flex;
      gap:8px;
      align-items:center;
    }

    /* Services grid */
    .grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:12px;
      margin-top:8px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.006));
      border-radius:12px;
      padding:14px;
      border:1px solid rgba(255,255,255,0.02);
    }
    .card h3{margin:0 0 6px 0;font-size:15px}
    .card p{margin:0;color:var(--muted);font-size:13px}

    /* Stern-but-playful FOSS policy */
    .policy{
      margin-top:12px;
      padding:14px;
      border-radius:10px;
      background: linear-gradient(180deg, rgba(14,165,164,0.03), rgba(124,58,237,0.02));
      border:1px solid rgba(255,255,255,0.02);
      font-size:14px;
      color:#e9f5f4;
    }
    .policy strong{color:#fff}

    /* Form */
    form.request{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      align-items:end;
    }
    form .full{grid-column:1/-1}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    input, textarea, select{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.01);
      color: #e8f3ff;
      font-size:14px;
      outline:none;
    }
    textarea{min-height:100px;resize:vertical}
    .small-muted{font-size:13px;color:var(--muted)}

    /* Footer */
    .footer{
      margin-top:auto;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      color:var(--muted);
      font-size:13px;
    }

    /* Responsive */
    @media (max-width:960px){
      .wrap{grid-template-columns: 1fr; min-height:700px}
      .sidebar{order:2}
      .content{order:1}
      .intro{max-width:100%}
      .grid{grid-template-columns: repeat(2,1fr)}
      form.request{grid-template-columns:1fr}
    }
    @media (max-width:520px){
      .grid{grid-template-columns:1fr}
      .logo{width:56px;height:56px;font-size:16px}
    }

    /* Accessibility reduced motion */
    @media (prefers-reduced-motion: reduce){
      *{transition:none!important;animation:none!important}
    }
  </style>
</head>
<body>
  <div class="wrap" role="main" aria-labelledby="site-title">
    <!-- SIDEBAR -->
    <aside class="sidebar" aria-label="Site navigation">
      <div class="brand">
        <div class="logo" aria-hidden="true">Râ€¢L</div>
        <div>
          <h1 id="site-title">Richard's Linux PC Repair</h1>
          <p>Fast. Friendly. Fiercely Free-Software-first.</p>
        </div>
      </div>

      <nav class="nav" aria-label="Primary">
        <a href="#services" class="active">Services</a>
        <a href="#pricing">Pricing</a>
        <a href="#policy">FOSS Policy</a>
        <a href="#contact">Contact</a>
      </nav>

      <div class="contact-card" aria-label="Contact">
        <h4>Book a repair</h4>
        <p class="muted">Phone: <strong>(555) 0-LINUX</strong><br/>Email: <strong>richard@linuxfix.example</strong></p>
        <a class="btn" href="#contact">Request Service</a>
      </div>
    </aside>

    <!-- MAIN CONTENT -->
    <section class="content">
      <div class="hero" role="region" aria-label="Introduction">
        <div class="intro">
          <h2>Professional Linux desktop & laptop repair</h2>
          <p class="muted">From kernel tweaks to hardware upgrades, Richard brings decades of experience supporting GNU/Linux systems. He loves tidy terminals, clean configs, and community-driven solutions.</p>
          <div style="margin-top:12px;">
            <span class="badge" aria-hidden="true">FOSS-first â€¢ Desktop & Server â€¢ Privacy-friendly</span>
          </div>
        </div>

        <div style="text-align:right;min-width:180px">
          <p class="muted">Open hours</p>
          <strong>Monâ€“Fri</strong><br/>
          <span class="small-muted">9:00am â€” 6:00pm</span>
        </div>
      </div>

      <!-- Services -->
      <section id="services" aria-labelledby="services-title">
        <h3 id="services-title" style="margin:0 0 8px 0">Core Services</h3>
        <div class="grid" role="list">
          <article class="card" role="listitem" aria-label="System diagnosis">
            <h3>System diagnosis</h3>
            <p class="muted">Comprehensive troubleshooting: boot issues, hardware detection, package conflicts, and performance analysis.</p>
          </article>
          <article class="card" role="listitem" aria-label="Data recovery">
            <h3>Data recovery</h3>
            <p class="muted">Disk salvage, live-USB data rescue, and secure transfer to new mediaâ€”done with care and clear communication.</p>
          </article>
          <article class="card" role="listitem" aria-label="Upgrades & installations">
            <h3>Upgrades & installations</h3>
            <p class="muted">Kernel upgrades, distro installs, desktop environment tweaks, and driver support for open-source stacks.</p>
          </article>
        </div>
      </section>

      <!-- Policy: Lighthearted yet stern -->
      <section id="policy" class="policy" aria-labelledby="policy-title" role="article">
        <h3 id="policy-title" style="margin:0 0 8px 0">FOSS-First Policy</h3>
        <p style="margin:0 0 6px 0">
          <strong>Short version:</strong> Richard is a diehard advocate of Free and Open Source Software. He lovingly supports and repairs Linux systems, open-hardware where reasonable, and software that respects your freedom.
        </p>
        <p style="margin:0">
          <strong>Important:</strong> He will <em>not</em> perform repairs on Windows-only or Apple macOS systems. That means no Windows re-installs, no closed-source driver wrangling for proprietary toolchains, and no Mac repairs. Think of it as politely stubborn: Richard will help you migrate or run Linux in parallel, but he won't bend his soldering iron for proprietary shackles.
        </p>
        <p class="small-muted" style="margin-top:8px">We say it with a smile, but we mean it: FOSS-first, always.</p>
      </section>

      <!-- Pricing & quick contact -->
      <section id="pricing" aria-labelledby="pricing-title">
        <h3 id="pricing-title" style="margin:0 0 8px 0">Pricing (sample)</h3>
        <div style="display:flex;gap:12px;flex-wrap:wrap">
          <div class="card" style="flex:1;min-width:200px">
            <h3>Diagnostics</h3>
            <p class="muted">Flat fee: <strong>$45</strong> (waived if repair proceeds).</p>
          </div>
          <div class="card" style="flex:1;min-width:200px">
            <h3>Hourly repair</h3>
            <p class="muted">From <strong>$85/hr</strong>. Labor estimated up front.</p>
          </div>
          <div class="card" style="flex:1;min-width:200px">
            <h3>Data recovery</h3>
            <p class="muted">Quoted per case. No-nonsense, transparent rates.</p>
          </div>
        </div>

        <form id="requestForm" class="request" aria-label="Service request form">
          <div>
            <label for="name">Your name</label>
            <input id="name" name="name" required placeholder="Ada Lovelace" />
          </div>
          <div>
            <label for="email">Email</label>
            <input id="email" name="email" type="email" required placeholder="you@example.org" />
          </div>
          <div class="full">
            <label for="system">System & model</label>
            <input id="system" name="system" required placeholder="e.g., ThinkPad T480, custom desktop (Intel i5), etc." />
            <p class="small-muted" style="margin-top:6px">Note: Richard only services machines running or intended to run Linux. If you're on Windows or macOS, list that and we'll discuss migration options instead.</p>
          </div>

          <div class="full">
            <label for="issue">Describe the issue</label>
            <textarea id="issue" name="issue" placeholder="Boot halt, noisy fan, won't detect NVMe, etc." required></textarea>
          </div>

          <div>
            <label for="when">Preferred date</label>
            <input id="when" name="when" type="date" />
          </div>

          <div>
            <button id="submitBtn" class="btn" type="submit">Submit request</button>
          </div>
        </form>
      </section>

      <div class="footer" aria-hidden="false">
        <div>Â© <strong>Richard's Linux PC Repair</strong> â€” Serving the FOSS community</div>
        <div class="small-muted">Privacy-first â€¢ No telemetry â€¢ We respect your data</div>
      </div>
    </section>
  </div>

  <script>
    // Minimal JS: handle form validation, lightweight UX, and gentle policy reminder.
    (function(){
      const form = document.getElementById('requestForm');
      const systemInput = document.getElementById('system');
      const issueInput = document.getElementById('issue');
      const emailInput = document.getElementById('email');
      const submitBtn = document.getElementById('submitBtn');

      form.addEventListener('submit', function(ev){
        ev.preventDefault();
        // Simple client-side check: detect if user explicitly states Windows or Mac/macOS
        const sys = (systemInput.value || '').toLowerCase();
        const issue = (issueInput.value || '').toLowerCase();
        const email = (emailInput.value || '').trim();

        if(!email){
          alert('Please provide a contact email.');
          emailInput.focus();
          return;
        }

        const mentionsProprietary = /windows|win10|win11|macintosh|mac os|macos|apple|imac|macbook/i;
        if(mentionsProprietary.test(sys) || mentionsProprietary.test(issue)){
          // Provide a friendly but firm notice and offer migration assistance
          const ok = confirm(
            "It looks like your note mentions Windows or macOS. " +
            "Richard does not repair Windows-only or Apple macOS systems. " +
            "Would you like a consultation about migrating to Linux (no pressure)? Click OK to request a migration consult; Cancel to revise your request."
          );
          if(!ok) return;
        }

        // Simulate submission (no external servers). Show summary to user.
        submitBtn.disabled = true;
        submitBtn.textContent = 'Sendingâ€¦';

        // Simulate a network delay
        setTimeout(()=>{
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit request';
          alert(
            "Request received â€” thank you! Richard will review your details and reply via email.\n\n" +
            "Reminder: he will not service Windows-only or Mac systems, but can discuss migration options."
          );
          form.reset();
        }, 850);
      });

      // Small accessibility: focus first input on load
      window.addEventListener('load', ()=> document.getElementById('name').focus());
    })();
  </script>
</body>
</html>
```
18. PASS
19. PASS
20. PASS
21. PASS
22. PASS
23. FAIL, SRC:
```
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

for num in range(1, 101):
    output = ""
    if num % 3 == 0:
        output += "Fizz"
    if num % 5 == 0:
        output += "Buzz"

    # If number is prime, reverse the word (if any)
    if is_prime(num) and output:
        output = output[::-1]

    # If no special word, just print the number
    print(output if output else num)
```
24. PASS, SRC:
```
def reverse_words(sentence):
    words = sentence.split()
    reversed_order = words[::-1]
    return " ".join(reversed_order)

# Example usage
print(reverse_words("hello world from AI"))  # Output: "AI from world hello"
```
25. PASS, SRC:
```
def palindrome_with_case_flip(s):
    # Remove spaces and make lowercase for palindrome check
    cleaned = "".join(s.split()).lower()
    is_palindrome = cleaned == cleaned[::-1]

    if is_palindrome:
        flipped = s.swapcase()  # Flip letter cases
        return flipped, True
    else:
        return s, False

# Example usage
result, is_pal = palindrome_with_case_flip("Never Odd Or Even")
print(result, is_pal)  # Output: nEVER oDD oR eVEN True

```
26. PASS, SRC:
```
def find_missing_number(nums):
    n = len(nums) + 1  # One number is missing
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum

# Example usage
print(find_missing_number([3, 7, 1, 2, 8, 4, 5]))  # Output: 6
```
27. PASS, SRC:
```
def calculator():
    result = 0
    last_operation = None  # (op, operand)

    print("Simple Calculator. Commands: +, -, *, /, undo, quit")
    print("Start value:", result)

    while True:
        cmd = input("> ").strip().lower()

        if cmd == "quit":
            break

        elif cmd == "undo":
            if last_operation:
                op, operand = last_operation
                if op == "+":
                    result -= operand
                elif op == "-":
                    result += operand
                elif op == "*":
                    result /= operand
                elif op == "/":
                    result *= operand
                print("Undo done. Result:", result)
                last_operation = None
            else:
                print("Nothing to undo.")

        else:
            try:
                op, num_str = cmd.split()
                num = float(num_str)
                if op == "+":
                    result += num
                elif op == "-":
                    result -= num
                elif op == "*":
                    result *= num
                elif op == "/":
                    if num == 0:
                        print("Error: Division by zero.")
                        continue
                    result /= num
                else:
                    print("Unknown operation.")
                    continue

                last_operation = (op, num)
                print("Result:", result)

            except ValueError:
                print("Invalid input. Example: + 5, * 2, undo, quit.")

if __name__ == "__main__":
    calculator()
```
28. PASS, SRC:

```
from collections import Counter

def find_rearrangements(dictionary, sentence):
    letters = Counter(sentence.replace(" ", "").lower())
    dictionary = [word.lower() for word in dictionary if not (Counter(word) - letters)]
    results = []

    def backtrack(path, remaining):
        if not remaining:
            results.append(" ".join(path))
            return
        for word in dictionary:
            word_count = Counter(word)
            if not (word_count - remaining):  # word can be formed
                backtrack(path + [word], remaining - word_count)

    backtrack([], letters)
    return results

# Example usage
dictionary = ["eat", "tea", "ate", "tan", "nat", "bat"]
sentence = "ate bat"
print(find_rearrangements(dictionary, sentence))

```

29. PASS (BUT BASIC), SRC:
```
import pygame
import math
import random

pygame.init()
WIDTH, HEIGHT = 800, 600
FPS = 60

screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("PyPinball")
clock = pygame.time.Clock()

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
YELLOW = (255, 255, 0)
RED = (255, 50, 50)
GREEN = (0, 255, 0)
BLUE = (50, 50, 255)

# Ball
ball_radius = 10
ball_pos = [WIDTH // 2, HEIGHT // 4]
ball_vel = [0, 0]

# Gravity
GRAVITY = 0.3
FRICTION = 0.99

# Flippers
flipper_length = 80
flipper_angle_left = -30
flipper_angle_right = 30
flipper_speed = 8
flipper_y = HEIGHT - 80
flipper_pivot_left = (WIDTH // 2 - 60, flipper_y)
flipper_pivot_right = (WIDTH // 2 + 60, flipper_y)
flipper_active_left = False
flipper_active_right = False

# Bumpers (x, y, radius, points)
bumpers = [
    (WIDTH // 2, HEIGHT // 2, 20, 100),
    (WIDTH // 2 - 100, HEIGHT // 2 - 100, 25, 150),
    (WIDTH // 2 + 100, HEIGHT // 2 - 100, 25, 150)
]

score = 0
font = pygame.font.SysFont(None, 36)

def draw_flipper(pivot, angle, color):
    x1, y1 = pivot
    rad = math.radians(angle)
    x2 = x1 + math.cos(rad) * flipper_length
    y2 = y1 + math.sin(rad) * flipper_length
    pygame.draw.line(screen, color, pivot, (x2, y2), 10)
    return (x2, y2)

def reset_ball():
    global ball_pos, ball_vel
    ball_pos = [WIDTH // 2, HEIGHT // 4]
    ball_vel = [random.uniform(-2, 2), 0]

reset_ball()

running = True
while running:
    dt = clock.tick(FPS) / 1000

    # --- Events ---
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                flipper_active_left = True
            elif event.key == pygame.K_RIGHT:
                flipper_active_right = True
        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT:
                flipper_active_left = False
            elif event.key == pygame.K_RIGHT:
                flipper_active_right = False

    # --- Physics ---
    ball_vel[1] += GRAVITY
    ball_vel[0] *= FRICTION
    ball_vel[1] *= FRICTION
    ball_pos[0] += ball_vel[0]
    ball_pos[1] += ball_vel[1]

    # Wall collisions
    if ball_pos[0] - ball_radius < 0:
        ball_pos[0] = ball_radius
        ball_vel[0] *= -1
    if ball_pos[0] + ball_radius > WIDTH:
        ball_pos[0] = WIDTH - ball_radius
        ball_vel[0] *= -1
    if ball_pos[1] - ball_radius < 0:
        ball_pos[1] = ball_radius
        ball_vel[1] *= -1

    # Bottom - lose ball
    if ball_pos[1] - ball_radius > HEIGHT:
        reset_ball()

    # Flipper control
    if flipper_active_left:
        flipper_angle_left = min(30, flipper_angle_left + flipper_speed)
    else:
        flipper_angle_left = max(-30, flipper_angle_left - flipper_speed)
    if flipper_active_right:
        flipper_angle_right = max(-30, flipper_angle_right - flipper_speed)
    else:
        flipper_angle_right = min(30, flipper_angle_right + flipper_speed)

    # Flipper collision (simple)
    left_end = draw_flipper(flipper_pivot_left, flipper_angle_left, GREEN)
    right_end = draw_flipper(flipper_pivot_right, flipper_angle_right, GREEN)

    for pivot, end, active in [
        (flipper_pivot_left, left_end, flipper_active_left),
        (flipper_pivot_right, right_end, flipper_active_right)
    ]:
        px, py = pivot
        ex, ey = end
        # Closest point on flipper to ball
        dx, dy = ex - px, ey - py
        t = ((ball_pos[0] - px) * dx + (ball_pos[1] - py) * dy) / (dx * dx + dy * dy)
        t = max(0, min(1, t))
        closest_x = px + t * dx
        closest_y = py + t * dy
        dist = math.hypot(ball_pos[0] - closest_x, ball_pos[1] - closest_y)
        if dist < ball_radius + 5:
            nx, ny = ball_pos[0] - closest_x, ball_pos[1] - closest_y
            length = math.hypot(nx, ny) or 1
            nx, ny = nx / length, ny / length
            ball_vel[0] += nx * (10 if active else 5)
            ball_vel[1] += ny * (10 if active else 5)

    # Bumper collisions
    for bx, by, br, points in bumpers:
        dist = math.hypot(ball_pos[0] - bx, ball_pos[1] - by)
        if dist < ball_radius + br:
            nx, ny = (ball_pos[0] - bx) / dist, (ball_pos[1] - by) / dist
            ball_vel[0] += nx * 5
            ball_vel[1] += ny * 5
            score += points

    # --- Draw ---
    screen.fill(BLACK)
    pygame.draw.circle(screen, YELLOW, (int(ball_pos[0]), int(ball_pos[1])), ball_radius)

    # Draw flippers
    left_end = draw_flipper(flipper_pivot_left, flipper_angle_left, GREEN)
    right_end = draw_flipper(flipper_pivot_right, flipper_angle_right, GREEN)

    # Draw bumpers
    for bx, by, br, points in bumpers:
        pygame.draw.circle(screen, RED, (bx, by), br)
        pygame.draw.circle(screen, WHITE, (bx, by), br, 2)

    # Score
    score_text = font.render(f"Score: {score}", True, WHITE)
    screen.blit(score_text, (10, 10))

    pygame.display.flip()

pygame.quit()

```

30. FAIL: AttributeError: 'panda3d.core.GraphicsWindow' object has no attribute 'setTitle'. SRC:
```
# simple_fps.py
# Simple Panda3D FPS: walk, jump, shoot cube-monsters.
# Requires: panda3d (Python3). Run: python simple_fps.py

from direct.showbase.ShowBase import ShowBase
from panda3d.core import WindowProperties, Vec3, CollisionTraverser, CollisionNode
from panda3d.core import CollisionHandlerQueue, CollisionRay, BitMask32, NodePath
from panda3d.core import KeyboardButton, CollisionSphere
from panda3d.core import AmbientLight, DirectionalLight
from direct.task import Task
import sys
import random
import math
import time

# Configurable gameplay constants
WALK_SPEED = 7.0
SPRINT_MULT = 1.8
JUMP_SPEED = 8.0
GRAVITY = 20.0
MOUSE_SENS = 0.12
FIRE_COOLDOWN = 0.18
BULLET_SPEED = 45.0
MONSTER_SPEED = 2.0

class SimpleFPS(ShowBase):
    def __init__(self):
        ShowBase.__init__(self)
        self.setWindowTitle("Simple Panda3D FPS Demo")

        # --- basic window / mouse setup ---
        self.disableMouse()  # we'll control the camera. See Panda3D manual about default camera driver. :contentReference[oaicite:1]{index=1}
        props = WindowProperties()
        props.setCursorHidden(True)
        props.setMouseMode(WindowProperties.M_relative)  # relative mouse mode where supported
        self.win.requestProperties(props)

        # Camera/player node
        self.player = render.attachNewNode("player")
        self.camera.reparentTo(self.player)
        self.camera.setPos(0, 0, 1.5)  # eye height

        # movement state
        self.key_map = {"forward": False, "back": False, "left": False, "right": False, "jump": False, "sprint": False}
        self.accept("w", self.set_key, ["forward", True])
        self.accept("w-up", self.set_key, ["forward", False])
        self.accept("s", self.set_key, ["back", True])
        self.accept("s-up", self.set_key, ["back", False])
        self.accept("a", self.set_key, ["left", True])
        self.accept("a-up", self.set_key, ["left", False])
        self.accept("d", self.set_key, ["right", True])
        self.accept("d-up", self.set_key, ["right", False])
        self.accept("space", self.set_key, ["jump", True])
        self.accept("space-up", self.set_key, ["jump", False])
        self.accept("shift", self.set_key, ["sprint", True])
        self.accept("shift-up", self.set_key, ["sprint", False])
        self.accept("escape", sys.exit)

        # mouse-fire
        self.accept("mouse1", self.fire)

        # --- scene: a simple floor and some cubes as walls/landmarks ---
        # Flat floor: we'll use a card (flattened plane)
        cm = self.loader.loadModel("models/misc/rgbCube")  # small cube model included in Panda3D installs; we'll scale/flatten it
        self.floor = cm.copyTo(render)
        self.floor.setScale(50, 50, 0.1)
        self.floor.setPos(0, 50, -0.1)
        self.floor.setColor(0.3, 0.3, 0.35, 1)

        # Add a few colored boxes as simple level geometry
        for i in range(10):
            b = cm.copyTo(render)
            b.setScale(1.5, 1.5, 2.5)
            x = random.uniform(-20, 20)
            y = random.uniform(-30, 30)
            b.setPos(x, y, 1.25)
            b.setColor(random.random(), random.random(), random.random(), 1)

        # lighting so cubes are visible
        al = AmbientLight("al")
        al.setColor((0.5, 0.5, 0.5, 1))
        render.setLight(render.attachNewNode(al))
        dl = DirectionalLight("dl")
        dl.setDirection(Vec3(-1, -1, -2))
        dl.setColor((0.8, 0.8, 0.75, 1))
        render.setLight(render.attachNewNode(dl))

        # --- ground detection using a downward collision ray ---
        # standard approach: cast a ray downwards each frame to detect ground (jump logic). See Panda3D forum/tutorial examples. :contentReference[oaicite:2]{index=2}
        self.cTrav = CollisionTraverser()
        self.groundHandler = CollisionHandlerQueue()
        self.groundRay = CollisionRay()
        self.groundRay.setOrigin(0, 0, 2.0)
        self.groundRay.setDirection(0, 0, -1)
        groundNode = CollisionNode('playerRay')
        groundNode.addSolid(self.groundRay)
        groundNode.setFromCollideMask(BitMask32.bit(0))
        groundNode.setIntoCollideMask(BitMask32.allOff())
        self.groundNp = self.player.attachNewNode(groundNode)
        self.cTrav.addCollider(self.groundNp, self.groundHandler)

        # make the floor and boxes into into-collide for that ray by adding collision solids:
        # Approach: attach a CollisionSphere slightly under floor for simplicity â€” but better approach is proper CollisionSolids per geometry.
        # For simplicity here, create a large invisible collision plane (we fake it using a big collision node).
        from panda3d.core import CollisionPlane, Plane, Point3, Vec3 as V3
        plane = CollisionPlane(Plane(V3(0, 0, 1), Point3(0, 0, 0)))
        pnode = CollisionNode('groundPlane')
        pnode.addSolid(plane)
        pnode.setIntoCollideMask(BitMask32.bit(0))
        render.attachNewNode(pnode)

        # --- physics variables ---
        self.velocity = Vec3(0, 0, 0)
        self.is_on_ground = False

        # --- bullets and monsters management ---
        self.last_fire = 0.0
        self.bullets = []
        self.monsters = []
        self.spawn_monsters(8)

        # update task
        self.taskMgr.add(self.update, "update")

        # confine mouse to window and reset pointer tracking
        self.win.movePointer(0, int(self.win.getProperties().getXSize() / 2),
                             int(self.win.getProperties().getYSize() / 2))

    def setWindowTitle(self, title):  # fallback if setWindowTitle unavailable
        try:
            base.win.setTitle(title)
        except Exception:
            pass

    def setWindowTitle(self, title):
        self.win.setTitle(title)

    def set_key(self, key, value):
        self.key_map[key] = value

    def spawn_monsters(self, n):
        model = self.loader.loadModel("models/misc/rgbCube")
        for i in range(n):
            m = model.copyTo(render)
            m.setScale(1.0, 1.0, 1.75)
            x = random.uniform(-30, 30)
            y = random.uniform(-30, 30)
            m.setPos(x, y, 0.9)
            m.setColor(0.8, 0.2, 0.2, 1)
            # simple health and id
            m.setPythonTag("hp", 3)
            self.monsters.append(m)

    def fire(self):
        now = time.time()
        if now - self.last_fire < FIRE_COOLDOWN:
            return
        self.last_fire = now
        # spawn a bullet as a small cube
        bm = self.loader.loadModel("models/misc/rgbCube")
        bullet = bm.copyTo(render)
        bullet.setScale(0.12, 0.12, 0.12)
        # start at camera position
        cam_world = self.camera.getPos(render)
        forward = self.camera.getQuat(render).getForward()
        bullet.setPos(cam_world + forward * 1.2)  # just in front of camera
        bullet.setColor(1.0, 1.0, 0.2, 1)
        # set velocity vector
        bullet.setPythonTag("vel", forward * BULLET_SPEED)
        bullet.setPythonTag("ttl", 3.0)  # seconds to live
        self.bullets.append(bullet)

    def update(self, task):
        dt = globalClock.getDt()
        if dt > 0.1: dt = 0.1

        # ----- mouse look -----
        if self.win.movePointer:  # relative mode
            md = self.win.getPointer(0)
            cx = md.getX()
            cy = md.getY()
            # in relative mode the pointer is usually centered; instead ask relative movement
            # Many platforms with M_relative provide delta via getRawMouseData; fallback: use getPointer and recenter
            # Here we use a simple approach: recenter each frame and compute delta from center
            wx = int(self.win.getProperties().getXSize() / 2)
            wy = int(self.win.getProperties().getYSize() / 2)
            delta_x = cx - wx
            delta_y = cy - wy
            # apply rotation
            h = self.player.getH() - delta_x * MOUSE_SENS
            p = self.camera.getP() - delta_y * MOUSE_SENS
            p = max(-89, min(89, p))
            self.player.setH(h)
            self.camera.setP(p)
            # recenter
            self.win.movePointer(0, wx, wy)

        # ----- movement -----
        move_dir = Vec3(0, 0, 0)
        if self.key_map["forward"]:
            move_dir.y += 1
        if self.key_map["back"]:
            move_dir.y -= 1
        if self.key_map["left"]:
            move_dir.x -= 1
        if self.key_map["right"]:
            move_dir.x += 1
        if move_dir.length() > 0:
            move_dir.normalize()
        speed = WALK_SPEED * (SPRINT_MULT if self.key_map["sprint"] else 1.0)

        # local-space movement (player orientation)
        heading = self.player.getH(render)
        # convert move_dir from local to world
        mat = self.player.getMat(render)
        forward = mat.getRow3(1)
        right = mat.getRow3(0)
        desired = (right * move_dir.x + forward * move_dir.y) * speed

        # gravity & jumping
        # detect ground by casting the downward ray: run traverser and inspect collisions
        self.cTrav.traverse(render)
        self.is_on_ground = False
        if self.groundHandler.getNumEntries() > 0:
            self.groundHandler.sortEntries()
            entry = self.groundHandler.getEntry(0)
            z = entry.getSurfacePoint(render).getZ()
            # if very close to ground (within a small epsilon), we are on ground
            player_z = self.player.getZ(render)
            if (player_z - z) <= 0.35:
                self.is_on_ground = True
                # snap to ground to prevent sliding accumulation
                self.player.setZ(z)

        if self.key_map["jump"] and self.is_on_ground:
            self.velocity.z = JUMP_SPEED
        # apply gravity
        self.velocity.z -= GRAVITY * dt

        # combine horizontal velocity
        self.velocity.x = desired.x
        self.velocity.y = desired.y

        # integrate position
        self.player.setPos(self.player.getPos() + self.velocity * dt)

        # simple floor clamp so we don't fall forever through if ground detection fails
        if self.player.getZ() < -50:
            self.player.setPos(0, 0, 5)
            self.velocity = Vec3(0, 0, 0)

        # ----- bullets update: move and TTL, check hits -----
        for b in self.bullets[:]:
            vel = b.getPythonTag("vel")
            ttl = b.getPythonTag("ttl") - dt
            b.setPythonTag("ttl", ttl)
            b.setPos(b.getPos() + vel * dt)
            # check monster collisions with simple distance test
            for m in self.monsters[:]:
                if (b.getPos() - m.getPos()).length() < 0.9:
                    # hit!
                    hp = m.getPythonTag("hp") - 1
                    m.setPythonTag("hp", hp)
                    if hp <= 0:
                        try:
                            self.monsters.remove(m)
                            m.removeNode()
                        except Exception:
                            pass
                    # remove bullet
                    try:
                        self.bullets.remove(b)
                        b.removeNode()
                    except Exception:
                        pass
                    break
            if ttl <= 0:
                if b in self.bullets:
                    self.bullets.remove(b)
                    b.removeNode()

        # ----- monsters AI: simple seek player -----
        for m in self.monsters:
            dir_to_player = (self.player.getPos(render) - m.getPos(render))
            dir_to_player.z = 0
            if dir_to_player.length() > 0.01:
                dir_to_player.normalize()
                m.setPos(m.getPos() + dir_to_player * MONSTER_SPEED * dt)
            # if close to player, apply 'damage' (here we just push player back)
            if (m.getPos() - self.player.getPos()).length() < 1.2:
                # simple knockback
                push = (self.player.getPos() - m.getPos())
                push.setZ(0)
                if push.length() > 0:
                    push.normalize()
                    self.player.setPos(self.player.getPos() + push * 0.5)

        return Task.cont

if __name__ == "__main__":
    app = SimpleFPS()
    app.run()
```

31. FAIL (Did path tracing, No WASD/Jump/Fire like advertised), SRC:

```
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Ray & Path Tracer</title>
<style>
  :root { --bg:#111; --panel:#1c1c1c; --accent:#7dd3fc; --muted:#aaa; }
  body { margin:0; font-family: Inter, Roboto, Arial; background:var(--bg); color:#eee; display:flex; height:100vh; gap:12px; align-items:flex-start; padding:12px; box-sizing:border-box;}
  .panel { background:var(--panel); padding:12px; border-radius:8px; box-shadow: 0 6px 24px rgba(0,0,0,.6);}
  #container { display:flex; gap:12px; align-items:flex-start; width:100%; }
  #canvasWrap { flex:1; display:flex; align-items:center; justify-content:center; }
  canvas { background:#000; image-rendering: pixelated; border-radius:6px; }
  .controls { width:300px; max-height:calc(100vh - 24px); overflow:auto; }
  h1 { margin:0 0 8px 0; font-size:18px; color:var(--accent); }
  label { display:block; font-size:13px; margin-top:8px; color:var(--muted); }
  input[type=range] { width:100%; }
  .row { display:flex; gap:8px; align-items:center; }
  button { margin-top:10px; width:100%; padding:8px; background:var(--accent); color:#022; border:none; border-radius:6px; cursor:pointer; font-weight:600; }
  small { color:var(--muted); }
  .stat { font-family: monospace; color:#ddd; margin-top:6px; }
  .modeBtn { width:48%; padding:6px; border-radius:6px; border:none; cursor:pointer; background:#222; color:#ddd; }
  .modeBtn.active { background:var(--accent); color:#022; }
</style>
</head>
<body>
<div id="container">
  <div id="canvasWrap" class="panel">
    <canvas id="canvas" width="640" height="384"></canvas>
  </div>

  <div class="controls panel">
    <h1>Mini Tracer</h1>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="resetBtn">Reset</button>
    </div>

    <label>Mode</label>
    <div class="row">
      <button class="modeBtn active" id="modeRay">Ray Trace</button>
      <button class="modeBtn" id="modePath">Path Trace</button>
    </div>

    <label>Resolution scale: <small id="resLabel">1.0</small></label>
    <input id="resRange" type="range" min="0.25" max="1" step="0.25" value="1">

    <label>Samples per pixel (progressive for path): <small id="sppLabel">1</small></label>
    <input id="sppRange" type="range" min="1" max="512" step="1" value="1">

    <label>Max bounces (path): <small id="bouncesLabel">3</small></label>
    <input id="bounceRange" type="range" min="1" max="8" step="1" value="3">

    <label>FOV (deg)</label>
    <input id="fovRange" type="range" min="40" max="90" step="1" value="60">

    <label>Gamma</label>
    <input id="gammaRange" type="range" min="1" max="3" step="0.1" value="2.2">

    <label><input type="checkbox" id="antialias" checked> Antialias (subpixel jitter)</label>
    <div class="stat" id="stats">Samples: 0 â€¢ Time: 0s</div>

    <hr style="opacity:.1;margin:10px 0;">
    <small>Controls: WASD move, mouse to look (click canvas to capture), Space to jump, LMB to fire (path tracer: render samples progressive).</small>
  </div>
</div>

<script>
/*
  Simple Ray & Path Tracer (single-file)
  - Ray Trace: direct lighting, shadows, reflections
  - Path Trace: Monte Carlo, diffuse sampling, multiple bounces, progressive accumulation
  No external libs. Keep it simple and educational.
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', {alpha:false});
let W = canvas.width, H = canvas.height;

const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const modeRay = document.getElementById('modeRay');
const modePath = document.getElementById('modePath');
const resRange = document.getElementById('resRange');
const sppRange = document.getElementById('sppRange');
const bounceRange = document.getElementById('bounceRange');
const fovRange = document.getElementById('fovRange');
const gammaRange = document.getElementById('gammaRange');
const antialias = document.getElementById('antialias');
const stats = document.getElementById('stats');
const resLabel = document.getElementById('resLabel');
const sppLabel = document.getElementById('sppLabel');
const bouncesLabel = document.getElementById('bouncesLabel');

let running = false;
let mode = 'ray'; // 'ray' or 'path'

// Simple camera / scene setup
let cam = {
  pos: {x:0,y:-6,z:1.2},
  target: {x:0,y:0,z:1},
  yaw: 0,
  pitch: 0,
  fov: 60
};

// scene objects: spheres and plane
class Sphere {
  constructor(x,y,z,r, color, emission=0, material='diffuse') {
    this.pos = {x,y,z}; this.r = r; this.color = color; this.emission = emission; this.material = material;
  }
}
let scene = [];
function makeScene() {
  scene = [];
  // ground plane is handled separately by ray-sphere-plane intersection
  // big spheres: color, some mirror, some emissive
  scene.push(new Sphere(-1.5, 1.5, 0.7, 0.7, {r:0.8,g:0.1,b:0.1}, 0, 'diffuse'));
  scene.push(new Sphere(1.2, 0.5, 0.6, 0.6, {r:0.1,g:0.1,b:0.8}, 0, 'specular'));
  scene.push(new Sphere(0.2, -0.5, 0.4, 0.4, {r:0.8,g:0.8,b:0.1}, 0, 'diffuse'));
  // light (emissive)
  scene.push(new Sphere(-0.5, -1.8, 4.0, 0.5, {r:1,g:1,b:1}, 6.0, 'diffuse'));
}

// utility helpers
function addVec(a,b){return {x:a.x+b.x,y:a.y+b.y,z:a.z+b.z};}
function subVec(a,b){return {x:a.x-b.x,y:a.y-b.y,z:a.z-b.z};}
function mulVec(a,s){return {x:a.x*s,y:a.y*s,z:a.z*s};}
function dot(a,b){return a.x*b.x + a.y*b.y + a.z*b.z;}
function len(v){return Math.sqrt(dot(v,v));}
function normalize(v){ let L=len(v); return L===0?{x:0,y:0,z:0}:mulVec(v,1/L); }
function reflect(I,N){ return subVec(I, mulVec(N, 2*dot(I,N))); }
function clamp01(x){ return x<0?0:(x>1?1:x); }

// ray-sphere intersection
function intersectSphere(ro, rd, sphere) {
  const oc = subVec(ro, sphere.pos);
  const a = dot(rd, rd);
  const b = 2*dot(oc, rd);
  const c = dot(oc, oc) - sphere.r*sphere.r;
  const disc = b*b - 4*a*c;
  if (disc < 0) return null;
  const sq = Math.sqrt(disc);
  const t0 = (-b - sq) / (2*a);
  const t1 = (-b + sq) / (2*a);
  let t = t0;
  if (t < 1e-4) t = t1;
  if (t < 1e-4) return null;
  const pos = addVec(ro, mulVec(rd, t));
  const n = normalize(subVec(pos, sphere.pos));
  return {t, pos, n, sphere};
}

// intersect with plane y = ? (we'll use z=0 plane as ground)
function intersectPlane(ro, rd) {
  // plane z = 0, normal (0,0,1)
  const n = {x:0,y:0,z:1};
  if (Math.abs(rd.z) < 1e-6) return null;
  const t = - (ro.z) / rd.z;
  if (t < 1e-4) return null;
  const pos = addVec(ro, mulVec(rd,t));
  return {t, pos, n, plane:true};
}

// pick nearest hit between spheres and plane
function sceneIntersect(ro, rd) {
  let hit = null;
  // spheres
  for (let s of scene) {
    const r = intersectSphere(ro, rd, s);
    if (r && (!hit || r.t < hit.t)) hit = r;
  }
  // plane (ground), only if it is nearer
  const p = intersectPlane(ro, rd);
  if (p && (!hit || p.t < hit.t)) {
    // plane color is checkerboard
    hit = p;
    hit.color = (((Math.floor(p.pos.x) + Math.floor(p.pos.y)) & 1) === 0) ? {r:0.9,g:0.9,b:0.9} : {r:0.2,g:0.2,b:0.2};
    hit.emission = 0;
    hit.material = 'diffuse';
  }
  return hit;
}

// simple direct ray tracer: one bounce reflections, shadows, and emitter sampling
function traceRay(ro, rd, depth=0) {
  const hit = sceneIntersect(ro, rd);
  if (!hit) {
    // sky
    const t = 0.5*(rd.z + 1.0);
    return {r: (1-t)*0.6 + t*0.8, g:(1-t)*0.7 + t*0.9, b:(1-t)*1.0 + t*1.0};
  }
  // emissive sphere -> return its emission scaled by color
  if (hit.sphere && hit.sphere.emission > 0) {
    return {r: hit.sphere.emission * (hit.sphere.color.r||1),
            g: hit.sphere.emission * (hit.sphere.color.g||1),
            b: hit.sphere.emission * (hit.sphere.color.b||1)};
  }
  // compute local color: for ray tracer we'll do direct lighting from emissive spheres
  // sample each emissive sphere once (simple)
  let baseColor = hit.sphere ? hit.sphere.color : hit.color;
  let accum = {r:0,g:0,b:0};
  // ambient
  accum.r += 0.03 * baseColor.r;
  accum.g += 0.03 * baseColor.g;
  accum.b += 0.03 * baseColor.b;

  // reflectivity for specular
  if (hit.sphere && hit.sphere.material === 'specular' && depth < 2) {
    const refl = reflect(rd, hit.n);
    const col = traceRay(addVec(hit.pos, mulVec(hit.n, 1e-4)), normalize(refl), depth+1);
    return col; // mirror - ignore base color for simplicity
  }

  // direct light from emissive spheres
  for (let s of scene) {
    if (!s.emission) continue;
    // sample toward light center (very approximate)
    const toLight = normalize(subVec(s.pos, hit.pos));
    // shadow test
    const shadow = sceneIntersect(addVec(hit.pos, mulVec(hit.n, 1e-4)), toLight);
    const lightDist = len(subVec(s.pos, hit.pos));
    if (!shadow || shadow.t > lightDist - 1e-4) {
      // lambert
      const lam = Math.max(0, dot(hit.n, toLight));
      const att = s.emission / (lightDist*lightDist + 0.001);
      accum.r += baseColor.r * s.color.r * lam * att;
      accum.g += baseColor.g * s.color.g * lam * att;
      accum.b += baseColor.b * s.color.b * lam * att;
    }
  }

  // small reflection for glossy diffuse
  if (depth < 2) {
    const refl = reflect(rd, hit.n);
    const col = traceRay(addVec(hit.pos, mulVec(hit.n, 1e-4)), normalize(refl), depth+1);
    accum.r += 0.2 * col.r;
    accum.g += 0.2 * col.g;
    accum.b += 0.2 * col.b;
  }

  // modulate by base color
  accum.r = accum.r * baseColor.r;
  accum.g = accum.g * baseColor.g;
  accum.b = accum.b * baseColor.b;

  return accum;
}

// Path tracing: returns radiance by Monte Carlo sampling
function pathTrace(ro, rd, maxBounces) {
  let radiance = {r:0,g:0,b:0};
  let throughput = {r:1,g:1,b:1};
  let origin = ro;
  let dir = rd;

  for (let bounce=0; bounce<maxBounces; bounce++) {
    const hit = sceneIntersect(origin, dir);
    if (!hit) {
      // environment (black-ish)
      radiance.r += throughput.r * 0.0;
      radiance.g += throughput.g * 0.0;
      radiance.b += throughput.b * 0.0;
      break;
    }
    // emissive
    if (hit.sphere && hit.sphere.emission > 0) {
      radiance.r += throughput.r * hit.sphere.emission * (hit.sphere.color.r||1);
      radiance.g += throughput.g * hit.sphere.emission * (hit.sphere.color.g||1);
      radiance.b += throughput.b * hit.sphere.emission * (hit.sphere.color.b||1);
      break; // assume light is small, stop on hitting light
    }
    // HANDLE MATERIALS: diffuse or specular
    const mat = (hit.sphere && hit.sphere.material) ? hit.sphere.material : hit.material || 'diffuse';
    if (mat === 'specular') {
      // perfect mirror
      dir = reflect(dir, hit.n);
      origin = addVec(hit.pos, mulVec(hit.n, 1e-4));
      // throughput unchanged for mirror
      continue;
    } else {
      // diffuse: sample cosine-weighted hemisphere
      const sample = cosineSampleHemisphere(hit.n);
      dir = sample;
      origin = addVec(hit.pos, mulVec(hit.n, 1e-4));
      // assume albedo = base color
      const base = hit.sphere ? hit.sphere.color : hit.color;
      // BRDF for diffuse is albedo / pi, but we account for pdf in sampling: pdf = cos/PI => multiply by cos/pdf = PI
      // throughput *= albedo
      throughput.r *= base.r;
      throughput.g *= base.g;
      throughput.b *= base.b;
      // Russian roulette termination to avoid infinite loops
      const p = Math.max(throughput.r, throughput.g, throughput.b);
      if (bounce > 2) {
        if (Math.random() > p) break;
        throughput.r /= p; throughput.g /= p; throughput.b /= p;
      }
    }
  }
  return radiance;
}

// cosine-weighted hemisphere sampling oriented by normal n
function cosineSampleHemisphere(n) {
  // sample in tangent space
  const u1 = Math.random(), u2 = Math.random();
  const r = Math.sqrt(u1);
  const theta = 2 * Math.PI * u2;
  const x = r * Math.cos(theta), y = r * Math.sin(theta), z = Math.sqrt(Math.max(0, 1-u1));
  // build orthonormal basis (n, t, b)
  let up = Math.abs(n.z) < 0.999 ? {x:0,y:0,z:1} : {x:1,y:0,z:0};
  let t = normalize(cross(up, n));
  let b = cross(n, t);
  // transform
  return normalize(addVec(addVec(mulVec(t, x), mulVec(b,y)), mulVec(n,z)));
}

function cross(a,b){ return {x: a.y*b.z - a.z*b.y, y: a.z*b.x - a.x*b.z, z: a.x*b.y - a.y*b.x}; }

// Rendering & progressive accumulation
let accumulation = null; // Float32Array for accumulative color
let frameCount = 0;
let startTime = 0;

function resetAccum() {
  const sw = Math.max(1, Math.floor(W * parseFloat(resRange.value)));
  const sh = Math.max(1, Math.floor(H * parseFloat(resRange.value)));
  accumulation = new Float32Array(sw * sh * 3);
  frameCount = 0;
}

// render one sample (either ray or path)
function renderSample() {
  const scale = parseFloat(resRange.value);
  const sw = Math.max(1, Math.floor(W * scale));
  const sh = Math.max(1, Math.floor(H * scale));
  const spp = parseInt(sppRange.value, 10);
  const bounces = parseInt(bounceRange.value, 10);
  const gamma = parseFloat(gammaRange.value);
  const aa = antialias.checked;
  const fov = parseFloat(fovRange.value);

  if (!accumulation || accumulation.length !== sw*sh*3) resetAccum();

  // camera basis
  const aspect = sw / sh;
  const fovRad = (fov * Math.PI / 180);
  const halfH = Math.tan(fovRad*0.5);
  const halfW = halfH * aspect;

  // camera orientation from cam.yaw/cam.pitch
  const yaw = cam.yaw, pitch = cam.pitch;
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  const cp = Math.cos(pitch), sp = Math.sin(pitch);
  // camera forward vector (in world)
  const forward = normalize({x: sy*cp, y: cy*cp, z: sp});
  const right = normalize({x: cy, y: -sy, z: 0});
  const up = cross(right, forward);

  // For each pixel we do 1 sample per renderSample call (progressive)
  for (let y=0; y<sh; y++) {
    for (let x=0; x<sw; x++) {
      // subpixel jitter for AA / progressive
      let sx = x + (aa ? Math.random() : 0.5);
      let syv = y + (aa ? Math.random() : 0.5);
      // NDC [-1..1]
      const nx = (2*(sx+0.5)/sw - 1) * halfW;
      const ny = (1 - 2*(syv+0.5)/sh) * halfH;
      // direction in world space
      let dir = normalize(addVec(addVec(mulVec(right, nx), mulVec(up, ny)), forward));
      const ro = cam.pos;
      let color;
      if (mode === 'ray') {
        color = traceRay(ro, dir, 0);
      } else {
        color = pathTrace(ro, dir, bounces);
      }
      const idx = (y*sw + x)*3;
      accumulation[idx+0] += color.r;
      accumulation[idx+1] += color.g;
      accumulation[idx+2] += color.b;
    }
  }

  frameCount++;
  // draw to visible canvas (we upscale from sw/sh to W/H)
  const img = ctx.createImageData(W, H);
  // nearest-neighbor upscale for speed
  for (let yy=0; yy<H; yy++) {
    for (let xx=0; xx<W; xx++) {
      const sx = Math.floor(xx * (sw / W));
      const syy = Math.floor(yy * (sh / H));
      const idx = (syy*sw + sx)*3;
      const r = accumulation[idx+0] / frameCount;
      const g = accumulation[idx+1] / frameCount;
      const b = accumulation[idx+2] / frameCount;
      // apply simple exposure/gamma
      const toGamma = v => Math.pow(clamp01(v), 1/gamma);
      const ir = Math.max(0, Math.min(255, Math.floor(toGamma(r) * 255)));
      const ig = Math.max(0, Math.min(255, Math.floor(toGamma(g) * 255)));
      const ib = Math.max(0, Math.min(255, Math.floor(toGamma(b) * 255)));
      const off = (yy*W + xx) * 4;
      img.data[off+0] = ir;
      img.data[off+1] = ig;
      img.data[off+2] = ib;
      img.data[off+3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);

  const elapsed = ((performance.now() - startTime)/1000).toFixed(1);
  stats.textContent = `Samples: ${frameCount} â€¢ Time: ${elapsed}s`;
}

// animation loop for progressive path tracing
let raf = null;
function loop() {
  if (!running) return;
  // render one progressive sample per frame (you can increase to more for faster accumulation)
  renderSample();
  raf = requestAnimationFrame(loop);
}

function start() {
  if (running) return;
  running = true;
  startBtn.textContent = 'Running...';
  startBtn.disabled = true;
  resetAccum();
  startTime = performance.now();
  raf = requestAnimationFrame(loop);
}

function stop() {
  running = false;
  startBtn.textContent = 'Start';
  startBtn.disabled = false;
  if (raf) cancelAnimationFrame(raf);
}

startBtn.onclick = () => {
  if (!running) start();
};
resetBtn.onclick = () => {
  stop();
  resetAccum();
  renderSample();
};

modeRay.onclick = () => { mode = 'ray'; modeRay.classList.add('active'); modePath.classList.remove('active'); resetAccum(); renderSample(); };
modePath.onclick = () => { mode = 'path'; modeRay.classList.remove('active'); modePath.classList.add('active'); resetAccum(); renderSample(); };

resRange.oninput = () => { resLabel.textContent = resRange.value; resetAccum(); renderSample(); };
sppRange.oninput = () => { sppLabel.textContent = sppRange.value; resetAccum(); renderSample(); };
bounceRange.oninput = () => { bouncesLabel.textContent = bounceRange.value; resetAccum(); renderSample(); };
fovRange.oninput = () => { cam.fov = parseFloat(fovRange.value); resetAccum(); renderSample(); };
gammaRange.oninput = () => { resetAccum(); renderSample(); };

canvas.onclick = () => {
  canvas.requestPointerLock?.();
};

// Basic controls (optional, nonessential): rotate camera with mouse movement while pointer locked
document.addEventListener('pointerlockchange', ()=> {
  // nothing special
});
document.addEventListener('mousemove', (e) => {
  if (document.pointerLockElement === canvas) {
    cam.yaw -= e.movementX * 0.0025;
    cam.pitch -= e.movementY * 0.0025;
    cam.pitch = Math.max(-1.4, Math.min(1.4, cam.pitch));
    cam.pos.x = Math.sin(cam.yaw) * -6;
    cam.pos.y = Math.cos(cam.yaw) * -6;
    cam.pos.z = 1.2 + Math.sin(cam.pitch)*0.5;
    resetAccum();
  }
});

// initialize scene and render initial sample
makeScene();
resetAccum();
renderSample();

</script>
</body>
</html>
```
32. PASS
33. FAIL (Implied that New Mexico MIGHT have a coast)
34. PASS
35. PASS
36. PASS
37. PASS
38. PASS
39. PASS, SRC:
```
"""
Low-poly Earth-like planet simulator using Panda3D
Single-file script. No external assets or libraries required besides Panda3D.

Features:
- Procedural low-poly icosphere mesh (subdividable)
- Simple fractal noise-based terrain displacement (no external noise libs)
- Real-time rebuild with DirectGUI sliders for:
    - Planet radius
    - Subdivision level (0-3)
    - Terrain amplitude
    - Terrain frequency
    - Terrain octaves
    - Atmosphere thickness
    - Rotation speed
    - Seed
- Toggle atmosphere on/off
- Simple orbital-style camera controls (drag to rotate, scroll to zoom)

Run: python low_poly_planet.py
Requires Panda3D (pip install panda3d)
"""

from math import sqrt, sin, cos, pi
import random
import sys

from panda3d.core import (
    GeomVertexFormat, GeomVertexData, GeomVertexWriter,
    GeomTriangles, Geom, GeomNode, NodePath, Vec3, Vec4,
    TransparencyAttrib, CompassEffect, CullFaceAttrib, LVector3,
    AmbientLight, DirectionalLight
)
from direct.showbase.ShowBase import ShowBase
from direct.gui.DirectGui import (
    DirectSlider, DirectLabel, DirectCheckButton, DirectButton
)
from direct.task import Task

# ------------------ Utility: create an icosahedron and subdivide ------------------

def normalize(v):
    x, y, z = v
    mag = sqrt(x * x + y * y + z * z)
    if mag == 0:
        return (0.0, 0.0, 0.0)
    return (x / mag, y / mag, z / mag)


def mid_point(a, b):
    return normalize(((a[0] + b[0]) / 2.0, (a[1] + b[1]) / 2.0, (a[2] + b[2]) / 2.0))


def make_icosahedron():
    t = (1.0 + sqrt(5.0)) / 2.0
    verts = [
        normalize((-1,  t,  0)), normalize(( 1,  t,  0)), normalize((-1, -t,  0)), normalize(( 1, -t,  0)),
        normalize(( 0, -1,  t)), normalize(( 0,  1,  t)), normalize(( 0, -1, -t)), normalize(( 0,  1, -t)),
        normalize(( t,  0, -1)), normalize(( t,  0,  1)), normalize((-t,  0, -1)), normalize((-t,  0,  1)),
    ]
    faces = [
        (0, 11, 5), (0, 5, 1), (0, 1, 7), (0, 7, 10), (0, 10, 11),
        (1, 5, 9), (5, 11, 4), (11, 10, 2), (10, 7, 6), (7, 1, 8),
        (3, 9, 4), (3, 4, 2), (3, 2, 6), (3, 6, 8), (3, 8, 9),
        (4, 9, 5), (2, 4, 11), (6, 2, 10), (8, 6, 7), (9, 8, 1)
    ]
    return verts, faces


def subdivide(verts, faces):
    # Subdivide each triangle into 4 triangles (loop over faces)
    cache = {}
    def get_mid(i, j):
        key = tuple(sorted((i, j)))
        if key in cache:
            return cache[key]
        a = verts[i]
        b = verts[j]
        m = mid_point(a, b)
        idx = len(verts)
        verts.append(m)
        cache[key] = idx
        return idx

    new_faces = []
    for (i1, i2, i3) in faces:
        a = get_mid(i1, i2)
        b = get_mid(i2, i3)
        c = get_mid(i3, i1)
        new_faces.append((i1, a, c))
        new_faces.append((i2, b, a))
        new_faces.append((i3, c, b))
        new_faces.append((a, b, c))
    return verts, new_faces

# ------------------ Simple deterministic "noise" function ------------------
# Not Perlin, but good enough for artistic terrain. Uses trigonometric layering.

def hash3(x, y, z, seed=0):
    # simple pseudo-random from coords
    return sin(x * 12.9898 + y * 78.233 + z * 37.719 + seed * 4.2) * 43758.5453 - int(sin(x * 12.9898 + y * 78.233 + z * 37.719 + seed * 4.2) * 43758.5453)


def fractal_noise(x, y, z, frequency=1.0, octaves=3, seed=0):
    value = 0.0
    amp = 1.0
    freq = frequency
    max_amp = 0.0
    for _ in range(max(1, int(octaves))):
        # Use trigonometric pseudo-random pattern
        h = hash3(x * freq, y * freq, z * freq, seed)
        value += h * amp
        max_amp += amp
        amp *= 0.5
        freq *= 2.0
    return value / max_amp if max_amp != 0 else 0.0

# ------------------ Build Panda3D Geom from vertices and faces ------------------

def build_geom_node(verts, faces, radius=1.0, color_func=None):
    format = GeomVertexFormat.getV3n3c4()
    vdata = GeomVertexData('planet', format, Geom.UHStatic)
    vwriter = GeomVertexWriter(vdata, 'vertex')
    nwriter = GeomVertexWriter(vdata, 'normal')
    cwriter = GeomVertexWriter(vdata, 'color')

    # write vertices
    for v in verts:
        x, y, z = v
        vwriter.addData3f(x * radius, y * radius, z * radius)
        nwriter.addData3f(x, y, z)
        if color_func:
            c = color_func(v)
            cwriter.addData4f(*c)
        else:
            cwriter.addData4f(0.6, 0.7, 0.5, 1.0)

    tris = GeomTriangles(Geom.UHStatic)
    for (a, b, c) in faces:
        tris.addVertices(a, b, c)
        tris.closePrimitive()

    geom = Geom(vdata)
    geom.addPrimitive(tris)
    node = GeomNode('planetGeom')
    node.addGeom(geom)
    return node

# ------------------ Planet class that manages mesh + atmosphere and UI ------------------

class PlanetSimulator(ShowBase):
    def __init__(self):
        ShowBase.__init__(self)
        base.disableMouse()  # we will implement our own simple camera control

        # default parameters
        self.params = {
            'radius': 2.0,
            'subdiv': 2,
            'amplitude': 0.35,
            'frequency': 1.0,
            'octaves': 3,
            'atmos_thickness': 0.2,
            'rotation_speed': 10.0,  # degrees per second
            'seed': 0,
            'atmos_on': True,
        }

        # base geometry template (icosahedron)
        base_verts, base_faces = make_icosahedron()
        self.base_verts = base_verts[:]
        self.base_faces = base_faces[:]

        # node holders
        self.planet_np = NodePath('planet')
        self.planet_np.reparentTo(render)
        self.atmos_np = None

        # initial build
        self.build_planet()

        # lights
        self.setup_lights()

        # UI
        self.build_ui()

        # camera state
        self.cam_dist = 8.0
        self.cam_pitch = 15.0
        self.cam_yaw = 30.0
        self.update_camera()

        # input
        self.accept('wheel_up', self.zoom_in)
        self.accept('wheel_down', self.zoom_out)
        self.accept('mouse1', self.start_rotate)
        self.accept('mouse1-up', self.stop_rotate)
        self.taskMgr.add(self.rotate_task, 'rotateTask')

        self.mouse_down = False
        self.last_mouse = (0, 0)

    # ---------- camera ----------
    def update_camera(self):
        # spherical -> cartesian
        rad_pitch = self.cam_pitch * (pi / 180.0)
        rad_yaw = self.cam_yaw * (pi / 180.0)
        x = self.cam_dist * cos(rad_pitch) * sin(rad_yaw)
        y = -self.cam_dist * cos(rad_pitch) * cos(rad_yaw)
        z = self.cam_dist * sin(rad_pitch)
        base.camera.setPos(x, y, z)
        base.camera.lookAt(0, 0, 0)

    def zoom_in(self):
        self.cam_dist = max(2.0, self.cam_dist - 0.5)
        self.update_camera()

    def zoom_out(self):
        self.cam_dist = min(50.0, self.cam_dist + 0.5)
        self.update_camera()

    def start_rotate(self):
        if base.mouseWatcherNode.hasMouse():
            self.mouse_down = True
            m = base.mouseWatcherNode.getMouse()
            self.last_mouse = (m.getX(), m.getY())

    def stop_rotate(self):
        self.mouse_down = False

    def rotate_task(self, task):
        # auto rotation
        dt = globalClock.getDt()
        self.planet_np.setH(self.planet_np.getH() + self.params['rotation_speed'] * dt)

        # mouse drag rotates camera
        if self.mouse_down and base.mouseWatcherNode.hasMouse():
            m = base.mouseWatcherNode.getMouse()
            mx, my = m.getX(), m.getY()
            lx, ly = self.last_mouse
            dx = (mx - lx) * 180
            dy = (my - ly) * 180
            self.cam_yaw -= dx
            self.cam_pitch = max(-80, min(80, self.cam_pitch + dy))
            self.update_camera()
            self.last_mouse = (mx, my)
        return Task.cont

    # ---------- lights ----------
    def setup_lights(self):
        ambient = AmbientLight('ambient')
        ambient.setColor((0.25, 0.25, 0.3, 1))
        amb_np = render.attachNewNode(ambient)
        render.setLight(amb_np)

        dlight = DirectionalLight('dlight')
        dlight.setColor((1.0, 0.95, 0.9, 1))
        dnp = render.attachNewNode(dlight)
        dnp.setHpr(50, -30, 0)
        render.setLight(dnp)

    # ---------- rebuild terrain ----------
    def build_planet(self):
        # clear existing
        self.planet_np.node().removeAllChildren()

        # create subdivided icosphere
        verts = self.base_verts[:]
        faces = self.base_faces[:]
        for _ in range(max(0, int(self.params['subdiv']))):
            verts, faces = subdivide(verts, faces)

        # compute displaced vertices
        displaced = []
        for v in verts:
            x, y, z = v
            n = Vec3(x, y, z)
            # noise in local space
            nval = fractal_noise(x, y, z, frequency=self.params['frequency'], octaves=self.params['octaves'], seed=self.params['seed'])
            # amplitude scales displacement
            disp = 1.0 + nval * self.params['amplitude']
            displaced.append((x * disp, y * disp, z * disp))

        # color function based on displacement and normal
        def color_func(v):
            # choose color by height
            x, y, z = v
            nval = fractal_noise(x, y, z, frequency=self.params['frequency'], octaves=self.params['octaves'], seed=self.params['seed'])
            h = (nval + 1.0) * 0.5  # map roughly to 0..1
            # simple biomes: water (blue) if low, land (green) mid, mountain (gray/white) if high
            if h < 0.35:
                t = max(0.0, min(1.0, (h - 0.0) / 0.35))
                return (0.0 * (1 - t) + 0.0 * t, 0.05 * (1 - t) + 0.3 * t, 0.3 * (1 - t) + 0.6 * t, 1.0)
            elif h < 0.7:
                t = (h - 0.35) / (0.35)
                return (0.1 * (1 - t) + 0.2 * t, 0.25 * (1 - t) + 0.8 * t, 0.05 * (1 - t) + 0.2 * t, 1.0)
            else:
                t = (h - 0.7) / 0.3
                return (0.5 * (1 - t) + 0.9 * t, 0.5 * (1 - t) + 0.95 * t, 0.5 * (1 - t) + 0.95 * t, 1.0)

        # build geom
        node = build_geom_node(displaced, faces, radius=self.params['radius'], color_func=color_func)
        geom_np = self.planet_np.attachNewNode(node)
        geom_np.setTwoSided(True)
        geom_np.setRenderModeFilled()
        geom_np.setShaderAuto()

        # optional atmosphere
        self.build_atmosphere()

    def build_atmosphere(self):
        # remove old
        if self.atmos_np:
            self.atmos_np.removeNode()
            self.atmos_np = None
        if not self.params['atmos_on']:
            return

        # use a slightly larger sphere by rebuilding a low-poly icosphere scaled up
        verts = self.base_verts[:]
        faces = self.base_faces[:]
        for _ in range(2):
            verts, faces = subdivide(verts, faces)

        scale = self.params['radius'] * (1.0 + max(0.01, self.params['atmos_thickness']))
        # color based on thickness
        alpha = max(0.05, min(0.6, self.params['atmos_thickness']))

        def atmos_color(v):
            # bluish fade
            return (0.2, 0.5, 1.0, max(0.02, alpha * (1.0 - v[2] * 0.5)))

        node = build_geom_node(verts, faces, radius=scale, color_func=atmos_color)
        self.atmos_np = render.attachNewNode(node)
        self.atmos_np.setTransparency(TransparencyAttrib.M_alpha)
        self.atmos_np.setBin('transparent', 20)
        self.atmos_np.setDepthWrite(False)
        self.atmos_np.setTwoSided(True)
        # subtle scale/rotation effect
        self.atmos_np.setCompass()  # keep orientation steady if parent rotates

    # ---------- UI ----------
    def build_ui(self):
        x0 = -1.3
        y = 0.85
        spacing = 0.09

        def add_slider(name, param_key, minv, maxv, default, decimals=2):
            nonlocal y
            DirectLabel(text=name, scale=0.045, pos=(x0, 0, y+0.02), frameColor=(0,0,0,0))
            slider = DirectSlider(range=(minv, maxv), value=default, pageSize=(maxv-minv)/100.0,
                                  scale=0.45, pos=(x0+0.7, 0, y), command=self.on_slider_change, extraArgs=[param_key])
            y -= spacing
            return slider

        # sliders
        self.sl_radius = add_slider('Radius', 'radius', 0.5, 6.0, self.params['radius'])
        self.sl_subdiv = add_slider('Subdivision (0-3)', 'subdiv', 0, 3, self.params['subdiv'])
        self.sl_ampl = add_slider('Terrain amplitude', 'amplitude', 0.0, 1.5, self.params['amplitude'])
        self.sl_freq = add_slider('Terrain frequency', 'frequency', 0.2, 4.0, self.params['frequency'])
        self.sl_oct = add_slider('Octaves', 'octaves', 1, 6, self.params['octaves'])
        self.sl_atmos = add_slider('Atmos thickness', 'atmos_thickness', 0.0, 1.0, self.params['atmos_thickness'])
        self.sl_rot = add_slider('Rotation speed', 'rotation_speed', -60, 60, self.params['rotation_speed'])
        # seed slider
        self.sl_seed = add_slider('Seed', 'seed', 0, 9999, self.params['seed'])

        # atmosphere on/off
        self.atm_check = DirectCheckButton(text="Atmosphere", scale=0.06, pos=(x0, 0, y), indicatorValue=self.params['atmos_on'], command=self.on_toggle_atmos)
        y -= spacing

        # rebuild button
        DirectButton(text='Rebuild', scale=0.06, pos=(x0, 0, y), command=self.on_rebuild)
        y -= spacing

        # quick help
        DirectLabel(text='Drag mouse to orbit, scroll to zoom', scale=0.04, pos=(-0.2,0, -0.95), frameColor=(0,0,0,0))

    def on_slider_change(self, key):
        # read all sliders
        try:
            self.params['radius'] = float(self.sl_radius['value'])
            self.params['subdiv'] = int(round(float(self.sl_subdiv['value'])))
            self.params['amplitude'] = float(self.sl_ampl['value'])
            self.params['frequency'] = float(self.sl_freq['value'])
            self.params['octaves'] = int(round(float(self.sl_oct['value'])))
            self.params['atmos_thickness'] = float(self.sl_atmos['value'])
            self.params['rotation_speed'] = float(self.sl_rot['value'])
            self.params['seed'] = int(round(float(self.sl_seed['value'])))
        except Exception as e:
            print('UI read error', e)
        # live update planet
        self.build_planet()

    def on_toggle_atmos(self, state):
        self.params['atmos_on'] = bool(state)
        self.build_planet()

    def on_rebuild(self):
        self.build_planet()


if __name__ == '__main__':
    app = PlanetSimulator()
    app.run()
```
40. FAIL (Kinda close tho!)
```
Below are two Python files for a small **open-world, Toontown-like MMO** implemented using **Panda3D** (client) and the Python standard library (server). No external assets or libraries besides Panda3D are used. Save them as `server.py` and `client.py` in the same folder. Run `python server.py` first, then `python client.py` (you can run many clients to simulate multiple players).

---

server.py

```python
#!/usr/bin/env python3
"""
Minimal authoritative server for a Toontown-like toy MMO.
- TCP JSON protocol (newline-delimited)
- Keeps authoritative world: players, enemies (boxes), interactive elements, areas
- Broadcasts world snapshots to all connected clients

This is intentionally simple and readable, not a production server.
"""

import socket
import threading
import json
import time
import random
import traceback
from collections import defaultdict

HOST = '0.0.0.0'
PORT = 52000
TICK = 1.0 / 20.0  # 20 Hz
BROADCAST_INTERVAL = 1.0 / 10.0  # 10 Hz

# World configuration
AREAS = [
    {"name": "ToonTown Plaza", "bounds": (-50, -50, 50, 50)},
    {"name": "Silly Suburbs", "bounds": (60, -40, 140, 40)},
    {"name": "Boxy Bay", "bounds": (-140, -60, -60, 60)},
]

WEAPONS = ["scribble_slap", "squirt", "pie", "anvil_throw"]

next_entity_id = 1
entity_lock = threading.Lock()

def gen_id():
    global next_entity_id
    with entity_lock:
        eid = next_entity_id
        next_entity_id += 1
    return eid

class Player:
    def __init__(self, conn, addr):
        self.id = gen_id()
        self.conn = conn
        self.addr = addr
        self.name = f"Player{self.id}"
        self.x = random.uniform(-20, 20)
        self.y = random.uniform(-20, 20)
        self.hp = 137
        self.weapons = WEAPONS[:]  # all weapons by default
        self.area = area_for_pos(self.x, self.y)
        self.last_input_time = time.time()
        self.last_recv = time.time()

class Enemy:
    def __init__(self, area_name, level=1):
        self.id = gen_id()
        self.level = level
        self.hp = 20 * level
        self.x, self.y = spawn_point_for_area(area_name)
        self.area = area_name
        self.type = 'box'  # enemies are boxes of varied levels

# helpers

def area_for_pos(x, y):
    for a in AREAS:
        minx, miny, maxx, maxy = a['bounds']
        if minx <= x <= maxx and miny <= y <= maxy:
            return a['name']
    return AREAS[0]['name']


def spawn_point_for_area(area_name):
    for a in AREAS:
        if a['name'] == area_name:
            minx, miny, maxx, maxy = a['bounds']
            return (random.uniform(minx+2, maxx-2), random.uniform(miny+2, maxy-2))
    return (0,0)

# Server state
players = {}  # conn -> Player
players_by_id = {}
enemies = {}  # id -> Enemy
clients_lock = threading.Lock()

# simple interactive elements
interactive_elements = {
    # id: {x,y,type,state}
}

# populate some interactive elements
for i in range(1,6):
    interactive_elements[i] = {"id": i, "x": random.uniform(-30,30), "y": random.uniform(-30,30), "type": "button", "state": False}

# spawn enemies per area
def spawn_wave():
    for a in AREAS:
        count = random.randint(2,5)
        for _ in range(count):
            lvl = random.choices([1,2,3], weights=[60,30,10])[0]
            e = Enemy(a['name'], level=lvl)
            enemies[e.id] = e

spawn_wave()

# networking helpers (newline-delimited JSON)

def send_json(conn, obj):
    try:
        data = json.dumps(obj) + '\n'
        conn.sendall(data.encode('utf-8'))
    except Exception:
        # callers handle connection removal
        raise

# read single newline-terminated JSON message (non-blocking wrapper)

def recv_json(conn):
    try:
        data = b''
        while True:
            chunk = conn.recv(4096)
            if not chunk:
                return None
            data += chunk
            if b'\n' in data:
                line, rest = data.split(b'\n', 1)
                # put back rest into socket buffer isn't possible; so we assume messages come clean per recv call in this simple server.
                return json.loads(line.decode('utf-8'))
    except BlockingIOError:
        return None
    except Exception:
        return None

# handle client in thread

def client_thread(conn, addr):
    print('Client connected', addr)
    conn.settimeout(1.0)
    p = Player(conn, addr)
    with clients_lock:
        players[conn] = p
        players_by_id[p.id] = p
    # send welcome with assigned id and starting state
    try:
        send_json(conn, {"type":"welcome","your_id":p.id,"hp":p.hp,"weapons":p.weapons, "pos": [p.x,p.y]})
    except Exception:
        pass

    buffer = b''
    try:
        while True:
            try:
                data = conn.recv(4096)
                if not data:
                    break
            except socket.timeout:
                # regular tick handled by main loop
                continue
            except Exception:
                break

            buffer += data
            while b'\n' in buffer:
                line, buffer = buffer.split(b'\n', 1)
                if not line.strip():
                    continue
                try:
                    msg = json.loads(line.decode('utf-8'))
                except Exception:
                    print('Bad msg from', addr)
                    continue
                p.last_recv = time.time()
                handle_client_message(p, msg)
    except Exception:
        traceback.print_exc()
    finally:
        print('Client disconnected', addr)
        with clients_lock:
            try:
                del players[conn]
            except Exception:
                pass
            try:
                del players_by_id[p.id]
            except Exception:
                pass
        try:
            conn.close()
        except Exception:
            pass

# message handler

def handle_client_message(p, msg):
    # messages: {"type": "input", "move": [dx,dy]} or {"type":"action","action":"attack","target":id}
    t = msg.get('type')
    if t == 'input':
        mv = msg.get('move')
        if mv:
            # clamp small movement
            dx, dy = mv
            speed = 3.0
            p.x += max(-1, min(1, dx)) * speed * TICK
            p.y += max(-1, min(1, dy)) * speed * TICK
            p.area = area_for_pos(p.x, p.y)
            p.last_input_time = time.time()
    elif t == 'action':
        act = msg.get('action')
        if act == 'attack':
            target_id = msg.get('target')
            # simple attack: deal damage based on random weapon
            weapon = random.choice(p.weapons)
            dmg = random.randint(8, 20)
            if target_id in enemies:
                enemies[target_id].hp -= dmg
                if enemies[target_id].hp <= 0:
                    del enemies[target_id]
            # broadcast immediate tiny event by storing on player object
    elif t == 'interact':
        elem_id = msg.get('id')
        if elem_id in interactive_elements:
            e = interactive_elements[elem_id]
            e['state'] = not e['state']
            # interaction spawns a friendly hat (purely cosmetic) or heals player
            p.hp = min(137, p.hp + 10)

# world update: enemy AI and simple mechanics

def world_tick(dt):
    # enemies move towards nearest player in their area
    for eid, en in list(enemies.items()):
        # find nearest player in same area
        nearest = None
        nd = 1e9
        for pl in players_by_id.values():
            if pl.area != en.area: continue
            d = (pl.x - en.x)**2 + (pl.y - en.y)**2
            if d < nd:
                nd = d; nearest = pl
        if nearest:
            # move towards player
            speed = 1.0 + 0.2 * en.level
            if nd > 0.1:
                dx = nearest.x - en.x
                dy = nearest.y - en.y
                dist = (dx**2 + dy**2)**0.5
                en.x += (dx/dist) * speed * dt
                en.y += (dy/dist) * speed * dt
            # if close, attack
            if nd < 1.5:
                damage = 2 * en.level
                nearest.hp -= damage
                if nearest.hp <= 0:
                    # respawn player
                    nearest.hp = 137
                    nearest.x, nearest.y = spawn_point_for_area(nearest.area)

# broadcast world state
last_broadcast = 0.0

def broadcast_loop():
    global last_broadcast
    while True:
        now = time.time()
        if now - last_broadcast >= BROADCAST_INTERVAL:
            snapshot = build_snapshot()
            with clients_lock:
                for conn, p in list(players.items()):
                    try:
                        send_json(conn, {"type":"snapshot","world": snapshot})
                    except Exception:
                        # drop client; it'll be cleaned by their thread
                        try:
                            conn.close()
                        except Exception:
                            pass
            last_broadcast = now
        time.sleep(0.01)

def build_snapshot():
    # include players, enemies, interactive elements, areas
    pls = []
    for p in list(players_by_id.values()):
        pls.append({"id": p.id, "name": p.name, "x": p.x, "y": p.y, "hp": p.hp, "area": p.area})
    ens = []
    for e in list(enemies.values()):
        ens.append({"id": e.id, "type": e.type, "level": e.level, "x": e.x, "y": e.y, "hp": e.hp, "area": e.area})
    elems = list(interactive_elements.values())
    return {"time": time.time(), "players": pls, "enemies": ens, "elements": elems, "areas": AREAS}

# main server loop

def server_main():
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((HOST, PORT))
    srv.listen(32)
    srv.settimeout(1.0)
    print(f"Server listening on {HOST}:{PORT}")

    # start broadcaster
    threading.Thread(target=broadcast_loop, daemon=True).start()

    last_time = time.time()
    try:
        while True:
            # accept new clients
            try:
                conn, addr = srv.accept()
                conn.setblocking(True)
                threading.Thread(target=client_thread, args=(conn, addr), daemon=True).start()
            except socket.timeout:
                pass

            now = time.time()
            dt = now - last_time
            if dt >= TICK:
                # world tick
                world_tick(dt)
                last_time = now

            # optional: respawn enemies if low
            if len(enemies) < 8:
                spawn_wave()

    except KeyboardInterrupt:
        print('Shutting down server')
    finally:
        srv.close()

if __name__ == '__main__':
    server_main()
```

---

client.py

```python
#!/usr/bin/env python3
"""
Panda3D client for the toy MMO server.
- Connects to server, receives snapshots, renders simple world
- WASD to move, mouse click to attack nearest enemy
- Interactive elements can be clicked to toggle

Note: keep Panda3D installed. Run multiple clients to test multiplayer.
"""

import socket
import threading
import json
import time
import math
import random

from direct.showbase.ShowBase import ShowBase
from direct.task import Task
from panda3d.core import WindowProperties, TextNode, CardMaker, NodePath
from panda3d.core import CollisionTraverser, CollisionHandlerQueue, CollisionRay, CollisionNode

SERVER_HOST = '127.0.0.1'
SERVER_PORT = 52000

class NetClient(threading.Thread):
    def __init__(self, host, port, on_snapshot):
        super().__init__(daemon=True)
        self.host = host; self.port = port
        self.on_snapshot = on_snapshot
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.settimeout(5.0)
        self.running = True
        self.buffer = b''
        try:
            self.sock.connect((host, port))
            self.sock.settimeout(0.5)
        except Exception as e:
            print('Could not connect to server:', e)
            raise

    def run(self):
        while self.running:
            try:
                data = self.sock.recv(4096)
                if not data:
                    print('Server closed'); break
            except Exception:
                time.sleep(0.01); continue
            self.buffer += data
            while b'\n' in self.buffer:
                line, self.buffer = self.buffer.split(b'\n', 1)
                if not line.strip():
                    continue
                try:
                    msg = json.loads(line.decode('utf-8'))
                except Exception:
                    continue
                if msg.get('type') == 'snapshot':
                    self.on_snapshot(msg['world'])
                elif msg.get('type') == 'welcome':
                    print('Welcome from server, assigned id', msg.get('your_id'))

    def send(self, obj):
        try:
            self.sock.sendall((json.dumps(obj) + '\n').encode('utf-8'))
        except Exception:
            pass

    def close(self):
        self.running = False
        try:
            self.sock.close()
        except Exception:
            pass

class ToonClient(ShowBase):
    def __init__(self, server_host=SERVER_HOST, server_port=SERVER_PORT):
        ShowBase.__init__(self)
        self.disable_mouse()
        props = WindowProperties(); props.setTitle('Toon-ish MMO Client')
        self.win.requestProperties(props)

        self.net = NetClient(server_host, server_port, self.on_snapshot)
        self.net.start()

        # local interpolation state
        self.players = {}  # id -> node
        self.enemies = {}
        self.elements = {}
        self.local_id = None
        self.local_hp = 137

        # HUD
        self.hud_text = self.make_text('', pos=(0.02, 0.95), align=TextNode.ALeft)

        # create a simple ground
        cm = CardMaker('ground')
        cm.setFrame(-200,200,-200,200)
        ground = self.render.attachNewNode(cm.generate())
        ground.setP(-90)
        ground.setZ(0)
        ground.setColor(0.6, 0.9, 0.6, 1)

        # camera
        self.cam.setPos(0, -60, 30)
        self.cam.lookAt(0,0,0)

        # input state
        self.key_map = {k:False for k in ['w','s','a','d']}
        self.accept('w', self.set_key, ['w', True]); self.accept('w-up', self.set_key, ['w', False])
        self.accept('s', self.set_key, ['s', True]); self.accept('s-up', self.set_key, ['s', False])
        self.accept('a', self.set_key, ['a', True]); self.accept('a-up', self.set_key, ['a', False])
        self.accept('d', self.set_key, ['d', True]); self.accept('d-up', self.set_key, ['d', False])
        self.accept('mouse1', self.on_click)

        # collision for clicks
        self.picker = CollisionTraverser()
        self.queue = CollisionHandlerQueue()
        self.pickerNode = CollisionNode('mouseRay')
        self.pickerNP = self.camera.attachNewNode(self.pickerNode)
        self.pickerRay = CollisionRay()
        self.pickerNode.addSolid(self.pickerRay)
        self.picker.addCollider(self.pickerNP, self.queue)

        self.taskMgr.add(self.client_update, 'clientUpdate')

    def set_key(self, k, v):
        self.key_map[k] = v

    def make_text(self, txt, pos=(0,0), align=TextNode.ACenter):
        tn = TextNode('hud')
        tn.setText(txt)
        tn.setAlign(align)
        np = self.aspect2d.attachNewNode(tn)
        np.setScale(0.05)
        np.setPos(pos[0], 0, pos[1])
        return tn

    def on_snapshot(self, world):
        # update local model from server snapshot (we'll smoothly interpolate in render)
        # store as raw data and create nodes as necessary
        self.world = world
        # update players
        for p in world['players']:
            pid = p['id']
            if pid not in self.players:
                node = self.create_player_node(p)
                self.players[pid] = {'node': node, 'target': (p['x'], p['y']), 'hp': p['hp'], 'name': p['name']}
            else:
                self.players[pid]['target'] = (p['x'], p['y'])
                self.players[pid]['hp'] = p['hp']
                self.players[pid]['name'] = p['name']
        # enemies
        server_enemy_ids = set()
        for e in world['enemies']:
            server_enemy_ids.add(e['id'])
            if e['id'] not in self.enemies:
                node = self.create_enemy_node(e)
                self.enemies[e['id']] = {'node': node, 'target': (e['x'], e['y']), 'hp': e['hp'], 'level': e['level']}
            else:
                self.enemies[e['id']]['target'] = (e['x'], e['y'])
                self.enemies[e['id']]['hp'] = e['hp']
        # remove missing
        for eid in list(self.enemies.keys()):
            if eid not in server_enemy_ids:
                self.enemies[eid]['node'].removeNode(); del self.enemies[eid]
        # interactive elements
        for el in world['elements']:
            if el['id'] not in self.elements:
                node = self.create_element_node(el)
                self.elements[el['id']] = {'node': node, 'state': el['state']}
            else:
                self.elements[el['id']]['state'] = el['state']
        # find local player id and hp
        # best effort: find nearest player to camera center
        # server sends assigned id in welcome; we didn't parse itâ€”try inferring last seen player
        if hasattr(self, 'world'):
            # if local_id is None, pick a player whose name starts with "Player" and small id? we'll keep it simple and not assume identity.
            # But we can display a HUD with first player
            pass

    def create_player_node(self, p):
        # simple toon: a colored sphere-like card and a name label
        cm = CardMaker(f'player{p["id"]}')
        cm.setFrame(-1,1,-1,1)
        node = self.render.attachNewNode(cm.generate())
        node.setBillboardPointEye()
        node.setScale(1.0)
        node.setPos(p['x'], 0, 1)
        color = (random.random()*0.7+0.3, random.random()*0.7+0.3, random.random()*0.7+0.3,1)
        node.setColor(*color)
        return node

    def create_enemy_node(self, e):
        cm = CardMaker(f'enemy{e["id"]}')
        cm.setFrame(-1,1,-1,1)
        node = self.render.attachNewNode(cm.generate())
        node.setPos(e['x'], 0, 1)
        node.setScale(1.5)
        # color by level
        lev = e.get('level',1)
        node.setColor(0.6, 0.6-0.1*lev, 0.2+0.1*lev, 1)
        return node

    def create_element_node(self, el):
        cm = CardMaker(f'elem{el["id"]}')
        cm.setFrame(-0.8,0.8,-0.4,0.4)
        node = self.render.attachNewNode(cm.generate())
        node.setPos(el['x'], 0, 0.5)
        node.setScale(1.0)
        node.setColor(0.2,0.2,0.9,1)
        return node

    def client_update(self, task):
        dt = globalClock.getDt()
        # send input
        dx = dy = 0.0
        if self.key_map['w']: dy += 1
        if self.key_map['s']: dy -= 1
        if self.key_map['a']: dx -= 1
        if self.key_map['d']: dx += 1
        if dx or dy:
            self.net.send({"type":"input","move":[dx,dy]})
        # interpolate world objects
        for pid, info in list(self.players.items()):
            tx, ty = info['target']
            npnode = info['node']
            x,_,_ = npnode.getPos()
            # simple linear lerp on x axis; we only store x in pos, use y ignored by render
            newx = x + (tx - x) * min(5*dt, 1)
            npnode.setX(newx)
        for eid, info in list(self.enemies.items()):
            tx, ty = info['target']
            npnode = info['node']
            x,_,_ = npnode.getPos()
            newx = x + (tx - x) * min(5*dt, 1)
            npnode.setX(newx)
        # update HUD
        self.hud_text.setText(f"Players: {len(self.players)}  Enemies: {len(self.enemies)}")
        return Task.cont

    def on_click(self):
        # send attack command for nearest enemy to camera center
        if not self.enemies:
            return
        # pick nearest by x distance to camera center (which is 0 in our simplified render)
        nearest = None; nd = 1e9
        for eid, info in self.enemies.items():
            x,_,_ = info['node'].getPos()
            d = abs(x - 0)
            if d < nd:
                nd = d; nearest = eid
        if nearest:
            self.net.send({"type":"action","action":"attack","target": nearest})

    def destroy(self):
        self.net.close()
        ShowBase.destroy(self)

if __name__ == '__main__':
    try:
        app = ToonClient()
        app.run()
    except Exception as e:
        print('Error starting client:', e)
```

---

# Notes & how to run

1. Install Panda3D (`pip install panda3d`) if you haven't already.
2. Save `server.py` and `client.py` in the same folder.
3. Run `python server.py` in a terminal. Then run `python client.py` (one or more times) to connect.
4. Controls in client: WASD to move, mouse click to attack nearest enemy, click interactive elements using the mouse (left-click) â€” interactive element toggling and healing is simulated.

This is intentionally a compact example to be easy to extend: you can add better models, polish the network protocol, add reliable UDP, prediction, smoothing, player identity / login, and fancy UI. If you'd like, I can: add cosmetics, make character randomization choices visible in a spawn menu, improve interpolation, or convert to UDP for lower latency.

"""
41. FAIL (Uncaught SyntaxError: import declarations may only appear at top level of a module), SRC:
```
// fluture-fetch-example.js
// Requires fluture from a CDN for browser compatibility
import {chain, map, mapRej, fork, node, attempt} from 'https://cdn.skypack.dev/fluture';
import {compose, take, map as mapArr, prop} from 'https://cdn.skypack.dev/ramda';

// Create a Future from fetch using Fluture's "node" for callback-style functions
const fetchFuture = url =>
  node(done => {
    fetch(url)
      .then(res => res.json())
      .then(json => done(null, json))
      .catch(err => done(err, null));
  });

// Transform: keep first 5 items, map to {id, title}
const transformTodos = compose(
  take(5),
  mapArr(todo => ({ id: todo.id, title: todo.title }))
);

// Failure handler: always return [{error: "fetch failed"}]
const onError = () => [{ error: 'fetch failed' }];

// Main Future pipeline
const program =
  map(transformTodos)(
    mapRej(onError)(
      fetchFuture('https://jsonplaceholder.typicode.com/todos')
    )
  );

// Fork to perform the side-effect only at the end
fork(
  result => console.log(result), // Left branch is actually the resolved array because of mapRej
  result => console.log(result)
)(program);

```
42. FAIL (./main.go:12:5: it.NaturalNumbers[int]().Take undefined (type iter.Seq[int] has no field or method Take)
./main.go:17:22: undefined: slices.Reduce), SRC:
```
package main

import (
  "fmt"

  "github.com/BooleanCat/go-functional/v2/it"
  "golang.org/x/exp/slices"
)

func main() {
  sum := it.NaturalNumbers[int]().
    Take(50).
    Filter(func(n int) bool { return n%2 == 0 }).
    Map(func(n int) int { return n * n }).
    Collect()
  
  fmt.Println(slices.Reduce(sum, 0, func(acc, v int) int {
    return acc + v
  }))
}

```
